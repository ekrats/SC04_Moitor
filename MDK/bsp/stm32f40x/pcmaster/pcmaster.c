/** ###################################################################
**     THIS BEAN MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : PC_M1.C
**     Project   : DSPC51
**     Processor : 56F8037
**     Beantype  : PC_Master
**     Version   : Bean 01.032, Driver 01.13, CPU db: 2.87.237
**     Compiler  : Metrowerks DSP C Compiler
**     Date/Time : 2011-2-23, ÏÂÎç 01:51
**     Abstract  :
**          The PC master software application is a software tool initially created
**          for developers of Motor Control applications but it may be extended to any
**          application development. This tool allows control of an application remotely
**          from a user-friendly graphical environment running on a PC.
**     Comment   :
**         8030
**     Settings  :
**          AsynchroSerial                       : Inhr7
**
**          Initialization:
**              Recorder buffer length           : 512
**              Command buffer length            : 4
**              Data buffer size                 : 128
**              Recorder timebase                : 32816
**              Board firmware major number      : 5
**              Board firmware minor number      : 0
**              Device identification string     : PC Master communication !
**     Contents  :
**         pcmasterdrvInit     - Word16 PC_M1_pcmasterdrvInit(sPCMasterComm *p_sPCMasterComm);
**         pcmasterdrvIsr      - void PC_M1_pcmasterdrvIsr(void);
**         pcmasterdrvRecorder - void PC_M1_pcmasterdrvRecorder(void);
**
**     (c) Freescale Semiconductor
**     2004 All Rights Reserved
**
**     (c) Copyright UNIS, spol. s r.o. 1997-2006
**     UNIS, spol. s r.o.
**     Jundrovska 33
**     624 00 Brno
**     Czech Republic
**     http      : www.processorexpert.com
**     mail      : info@processorexpert.com
** ###################################################################*/

/* MODULE PC_M1. */

#include "pcmaster.h"
#include "string.h"
#include "rtthread.h"

/*lint -save -e960 Disable MISRA rule 98 checking */
/* Standard ANSI C types */
#include <stdint.h>


#ifndef FALSE
#define  FALSE  0                    /* Boolean value FALSE. FALSE is defined always as a zero value. */
#endif
#ifndef TRUE
#define  TRUE   1                    /* Boolean value TRUE. TRUE is defined always as a non zero value. */
#endif

#ifndef NULL
#define  NULL   0
#endif

/* PE types definition */
typedef unsigned int bool;
typedef unsigned char byte;
typedef unsigned short word;
typedef unsigned long dword;
typedef unsigned long dlong[2];
typedef uint8_t TPE_ErrCode;

/* SDK types definition */
typedef signed char    Word8;
typedef unsigned char  UWord8;
typedef short          Word16;
typedef unsigned short UWord16;
typedef long           Word32;
typedef unsigned long  UWord32;
typedef signed char    Int8;
typedef unsigned char  UInt8;
typedef signed short   Int16;
typedef unsigned short   UInt16;
typedef long           Int32;
typedef unsigned long  UInt32;
//typedef __typeof__(sizeof(0)) ssize_t;
typedef short ibool;

/**************************************************/
/* PE register access macros                      */
/**************************************************/
#define setRegBit(reg, bit)                                     (reg |= reg##_##bit##_##MASK)
#define clrRegBit(reg, bit)                                     (reg &= ~reg##_##bit##_##MASK)
#define getRegBit(reg, bit)                                     (reg & reg##_##bit##_##MASK)
#define setReg(reg, val)                                        (reg = (word)(val))
#define getReg(reg)                                             (reg)
#define setRegBits(reg, mask)                                   (reg |= (word)(mask))
#define getRegBits(reg, mask)                                   (reg & (word)(mask))
#define clrRegBits(reg, mask)                                   (reg &= (word)(~(mask)))
#define setRegBitGroup(reg, bits, val)                          (reg = (word)((reg & ~reg##_##bits##_##MASK) | ((val) << reg##_##bits##_##BITNUM)))
#define getRegBitGroup(reg, bits)                               ((reg & reg##_##bits##_##MASK) >> reg##_##bits##_##BITNUM)
#define setRegMask(reg, maskAnd, maskOr)                        (reg = (word)((getReg(reg) & ~(maskAnd)) | (maskOr)))
#define setRegBitVal(reg, bit, val)                             ((val) == 0 ? (reg &= ~reg##_##bit##_##MASK) : (reg |= reg##_##bit##_##MASK))
#define changeRegBits(reg, mask)                                (reg ^= (mask))
#define changeRegBit(reg, bit)                                  (reg ^= reg##_##bit##_##MASK)

/**************************************************/
/* Uniform multiplatform peripheral access macros */
/**************************************************/
#define setReg16Bit(RegName, BitName)                           (RegName |= RegName##_##BitName##_##MASK)
#define clrReg16Bit(RegName, BitName)                           (RegName &= ~RegName##_##BitName##_##MASK)
#define invertReg16Bit(RegName, BitName)                        (RegName ^= RegName##_##BitName##_##MASK)
#define testReg16Bit(RegName, BitName)                          (RegName & RegName##_##BitName##_##MASK)

/* Whole peripheral register access macros */
#define setReg16(RegName, val)                                   (RegName = (word)(val))
#define getReg16(RegName)                                        (RegName)

/* Bits peripheral register access macros */
#define testReg16Bits(RegName, GetMask)                          (RegName & (GetMask))
#define clrReg16Bits(RegName, ClrMask)                           (RegName &= ~(word)(ClrMask))
#define setReg16Bits(RegName, SetMask)                           (RegName |= (word)(SetMask))
#define invertReg16Bits(RegName, InvMask)                        (RegName ^= (word)(InvMask))
#define clrSetReg16Bits(RegName, ClrMask, SetMask)               (RegName = (RegName & (~(word)(ClrMask))) | (word)(SetMask))
#define seqClrSetReg16Bits(RegName, BitsMask, BitsVal)           ( RegName &= ~(~(word)(BitsVal) & (word)(BitsMask)),\
	RegName |= (word)(BitsVal) & (word)(BitsMask) )
#define seqSetClrReg16Bits(RegName, BitsMask, BitsVal)           ( RegName |= (word)(BitsVal) & (word)(BitsMask),\
	RegName &= ~(~(word)(BitsVal) & (word)(BitsMask)) )
#define seqResetSetReg16Bits(RegName, BitsMask, BitsVal)         ( RegName &= ~(word)(BitsMask),\
	RegName |= (word)(BitsVal) & (word)(BitsMask) )
#define clrReg16BitsByOne(RegName, ClrMask, BitsMask)            (RegName &= (word)(ClrMask) & (word)(BitsMask))

/* Bit group peripheral register access macros */
#define testReg16BitGroup(RegName, GroupName)                    (RegName & RegName##_##GroupName##_##MASK)
#define getReg16BitGroupVal(RegName, GroupName)                  ((RegName & RegName##_##GroupName##_##MASK) >> RegName##_##GroupName##_##BITNUM)
#define setReg16BitGroupVal(RegName, GroupName, GroupVal)        (RegName = (RegName & ~RegName##_##GroupName##_##MASK) | ((GroupVal) << RegName##_##GroupName##_##BITNUM))
#define seqClrSetReg16BitGroupVal(RegName,GroupName,GroupVal)    ( RegName &= ~(~((GroupVal) << RegName##_##GroupName##_##BITNUM) & RegName##_##GroupName##_##MASK),\
	RegName |= ((GroupVal) << RegName##_##GroupName##_##BITNUM) & RegName##_##GroupName##_##MASK )
#define seqSetClrReg16BitGroupVal(RegName,GroupName,GroupVal)    ( RegName |= ((GroupVal) << RegName##_##GroupName##_##BITNUM) & RegName##_##GroupName##_##MASK,\
	RegName &= ~(~((GroupVal) << RegName##_##GroupName##_##BITNUM) & RegName##_##GroupName##_##MASK) )
#define seqResetSetReg16BitGroupVal(RegName,GroupName,GroupVal)  ( RegName &= ~RegName##_##GroupName##_##MASK,\
	RegName |= ((GroupVal) << RegName##_##GroupName##_##BITNUM) & RegName##_##GroupName##_##MASK )




#define in16(var,l,h)  (var = ((word)(l)) | (((word)(h)) << 8))
#define out16(l,h,val) { l = (byte)(val); h = (byte)((val) >> 8); }

#define output(P, V) setReg(P,V)
#define input(P) getReg(P)

// #define __EI0() { asm(bfclr  #0x0300,SR); } /* Enable interrupts of level 0,1,2,3 */
// #define __EI1() { asm(bfset  #0x0100,SR); asm(bfclr  #0x0200,SR);} /* Enable interrupts of level 1,2,3 */
// #define __EI2() { asm(bfset  #0x0200,SR); asm(bfclr  #0x0100,SR);} /* Enable interrupts of level 2,3 */
// #define __EI3() { asm(bfset  #0x0300,SR); } /* Enable interrupts of level 3 */
// #define __EI(level)  __EI##level()     /* Enable interrupts of the given level */
// #define __DI()  __EI3()                /* Disable interrupts, only level 3 is allowed */

// #define SaveStatusReg()     { asm(move.w  SR,SR_reg); asm(bfset  #0x0300,SR); asm(nop); asm(nop); asm(nop); asm(nop); asm(nop); asm(nop); } /* Save status register and disable interrupts */
// #define RestoreStatusReg()  { asm(moveu.w SR_reg,SR); asm(nop); asm(nop); } /* Restore status register  */

/* Save status register and disable interrupts */
#define EnterCritical()     {\
	/*lint -save -esym(960,54) Disable MISRA rule (54) checking. */\
	if (++SR_lock == 1) SaveStatusReg();\
	/*lint -restore */\
}

/* Restore status register  */
#define ExitCritical()      {\
	/*lint -save -esym(960,54) Disable MISRA rule (54) checking. */\
	if (--SR_lock == 0) RestoreStatusReg();\
	/*lint -restore */\
}

typedef struct {          /* Black&White Image  */
	word width;             /* Image width  */
	word height;            /* Image height */
	byte *pixmap;           /* Image pixel bitmap */
	dword size;             /* Image size */
	char *name;             /* Image name */
} TIMAGE;
typedef struct TIMAGE* PIMAGE ; /* Pointer to image */

/* 16-bit register (big endian) */
typedef union {
	word w;
	struct {
		byte high,low;
	} b;
} TWREG;

typedef union
{
	struct
	{
		UWord16 LSBpart;
		Word16 MSBpart;
	} RegParts;

	Word32 Reg32bit;

} decoder_uReg32bit;

typedef struct
{
	union { Word16 PositionDifferenceHoldReg;
	Word16 posdh; }X;
	union { Word16 RevolutionHoldReg;
	Word16 revh; }Y;
	union { decoder_uReg32bit PositionHoldReg;
	Word32 posh; }Z;

}decoder_sState;

typedef struct
{
	UWord16 EncPulses;
	UWord16 RevolutionScale;

	Int16   scaleDiffPosCoef;
	UInt16  scalePosCoef;
	Int16   normDiffPosCoef;
	Int16   normPosCoef;
}decoder_sEncScale;

typedef struct
{
	UWord16 Index    :1;
	UWord16 PhaseB   :1;
	UWord16 PhaseA   :1;
	UWord16 Reserved :13;
}decoder_sEncSignals;

typedef union{
	decoder_sEncSignals  EncSignals;
	UWord16 Value;
} decoder_uEncSignals;

/******************************************************************************
*
* This Motor Control section contains generally useful and generic
* types that are used throughout the domain of motor control.
*
******************************************************************************/
/* Fractional data types for portability */
typedef short          Frac16;
typedef long           Frac32;

typedef enum
{
	mcPhaseA,
	mcPhaseB,
	mcPhaseC
} mc_ePhaseType;

typedef struct
{
	Frac16 PhaseA;
	Frac16 PhaseB;
	Frac16 PhaseC;
} mc_s3PhaseSystem;

/* general types, primary used in FOC */

typedef struct
{
	Frac16 alpha;
	Frac16 beta;
} mc_sPhase;

typedef struct
{
	Frac16 sine;
	Frac16 cosine;
} mc_sAngle;

typedef struct
{
	Frac16 d_axis;
	Frac16 q_axis;
} mc_sDQsystem;

typedef struct
{
	Frac16 psi_Rd;
	Frac16 omega_field;
	Frac16 i_Sd;
	Frac16 i_Sq;
} mc_sDQEstabl;

typedef UWord16 mc_tPWMSignalMask;    /*  pwm_tSignalMask contains six control bits
									  representing six PWM signals, shown below.
									  The bits can be combined in a numerical value
									  that represents the union of the appropriate
									  bits.  For example, the value 0x15 indicates
									  that PWM signals 0, 2, and 4 are set.
									  */

#define MC_PWM_SIGNAL_0       0x0001
#define MC_PWM_SIGNAL_1       0x0002
#define MC_PWM_SIGNAL_2       0x0004
#define MC_PWM_SIGNAL_3       0x0008
#define MC_PWM_SIGNAL_4       0x0010
#define MC_PWM_SIGNAL_5       0x0020
#define MC_PWM_NO_SIGNALS     0x0000     /* No (none) PWM signals */
#define MC_PWM_ALL_SIGNALS   (MC_PWM_SIGNAL_0 | \
	MC_PWM_SIGNAL_1 | \
	MC_PWM_SIGNAL_2 | \
	MC_PWM_SIGNAL_3 | \
	MC_PWM_SIGNAL_4 | \
	MC_PWM_SIGNAL_5)

/* general types, primary used in PI, PID and other controllers */

typedef struct
{
	Word16 ProportionalGain;
	Word16 ProportionalGainScale;
	Word16 IntegralGain;
	Word16 IntegralGainScale;
	Word16 DerivativeGain;
	Word16 DerivativeGainScale;
	Word16 PositivePIDLimit;
	Word16 NegativePIDLimit;
	Word16 IntegralPortionK_1;
	Word16 InputErrorK_1;
}mc_sPIDparams;

typedef struct
{
	Word16 ProportionalGain;
	Word16 ProportionalGainScale;
	Word16 IntegralGain;
	Word16 IntegralGainScale;
	Word16 PositivePILimit;
	Word16 NegativePILimit;
	Word16 IntegralPortionK_1;
}mc_sPIparams;

/*******************************************************
* Bit Manipulation Operations
*******************************************************/

/* void bitSet(Mask, Addr); */
#define bitSet(Mask, Addr)             ((Addr) |= (Mask)) //((void *) 0) //asm(bfset    Mask,Addr)

/* void bitClear(Mask, Addr); */
#define bitClear(Mask, Addr)            ((Addr) &= ~(Mask))//((void *) 0)//asm(bfclr    Mask,Addr)

/* void bitChange(Mask, Addr); */
#define bitChange(Mask, Addr)           ((void *) 0)//asm(bfchg    Mask,Addr)

/* void bitTestHigh(Mask, Addr); */
#define bitTestHigh(Mask, Addr)         ((void *) 0)//asm(bftsth   Mask,Addr)

/* void bitTestLow(Mask, Addr); */
#define bitTestLow(Mask, Addr)          ((void *) 0)//asm(bftstl   Mask,Addr)


/* void bitWordSet(Mask, Addr); */
#define bitWordSet(Mask, Addr)   (*Addr = Mask | *Addr)

/* void bitWordClear(Mask, Addr); */
#define bitWordClear(Mask, Addr) (*Addr = ~Mask & *Addr)

/* set configuration of PC Master */
/*-----------------
standard commands
-----------------*/
#define PCMDRV_CMD_READMEM          0x01 /* read block of memory */
#define PCMDRV_CMD_WRITEMEM         0x02 /* write block of memory */
#define PCMDRV_CMD_WRITEMEMMASK     0x03 /* write block of memory with mask */
#define PCMDRV_CMD_READMEMEX        0x04 /* v3+ */
#define PCMDRV_CMD_WRITEMEMEX       0x05 /* v3+ */
#define PCMDRV_CMD_WRITEMEMMASKEX   0x06 /* v3+ */
#define PCMDRV_CMD_SETUPSCOPE       0x08 /* setup scope */
#define PCMDRV_CMD_SETUPREC         0x09 /* setup recorder */
#define PCMDRV_CMD_SETUPSCOPEEX     0x0A /* v3+ */
#define PCMDRV_CMD_SETUPRECEX       0x0B /* v3+ */
#define PCMDRV_CMD_CALLAPPCMD       0x10 /* call user application command */

/*-----------------
special commands
-----------------*/
/* no data part */
#define PCMDRV_CMD_GETINFO          0xC0 /* get system information */
#define PCMDRV_CMD_STARTREC         0xC1 /* start recorder */
#define PCMDRV_CMD_STOPREC          0xC2 /* stop recorder */
#define PCMDRV_CMD_GETRECSTS        0xC3 /* get recorder status */
#define PCMDRV_CMD_GETRECBUFF       0xC4 /* get recorder buffer information */
#define PCMDRV_CMD_READSCOPE        0xC5 /* read scope variables */
#define PCMDRV_CMD_GETAPPCMDSTS     0xC6 /* get user application command status */
#define PCMDRV_CMD_GETINFOBRIEF     0xC8 /* v2+ get brief system information */
#define PCMDRV_CMD_GETRECBUFFEX     0xC9 /* v3+ */
/* 2 bytes data part */
#define PCMDRV_CMD_READVAR8         0xD0 /* read 8-bit variable from 16-bit address */
#define PCMDRV_CMD_READVAR16        0xD1 /* read 16-bit variable from 16-bit address */
#define PCMDRV_CMD_READVAR32        0xD2 /* read 32-bit variable from 16-bit address */
/* 4 bytes data part */
#define PCMDRV_CMD_READVAR8EX       0xE0 /* read 8-bit variable from 32-bit address */
#define PCMDRV_CMD_READVAR16EX      0xE1 /* read 16-bit variable from 32-bit address */
#define PCMDRV_CMD_READVAR32EX      0xE2 /* read 32-bit variable from 32-bit address */

/*-------------
status bytes
-------------*/
#define PCMDRV_STC_OK               0x00 /* operation succesful */
#define PCMDRV_STC_RECRUN           0x01 /* recorder running */
#define PCMDRV_STC_RECDONE          0x02 /* recorder finished */
/* error codes */
#define PCMDRV_STC_INVCMD           0x81 /* invalid command */
#define PCMDRV_STC_CMDSERR          0x82 /* checksum error */
#define PCMDRV_STC_CMDBUFFOVF       0x83 /* command too long */
#define PCMDRV_STC_RSPBUFFOVF       0x84 /* response would be too long */
#define PCMDRV_STC_INVBUFF          0x85 /* invalid buffer length specified */
#define PCMDRV_STC_INVSIZE          0x86 /* invalid size */
#define PCMDRV_STC_SERVBUSY         0x87 /* service is busy */
#define PCMDRV_STC_NOTINIT          0x88 /* scope/recorder not configured */
#define PCMDRV_STC_UNKNOWN          0xFF /* reserved */

/* recorder trigger modes */
#define PCMDRV_REC_TRIGOFF             0 /* manual mode (trigger disabled) */
#define PCMDRV_REC_TRIGRIS             1 /* rising edge */
#define PCMDRV_REC_TRIGFAL             2 /* falling edge */

#define PCMDRV_IDT_STRING_LEN         25 /* length of identification string */

/* get info command parameters */
#define PCMDRV_PROT_VER                3 /* PC Master protocol version */
#define PCMDRV_DATABUSWDT              1 /* data bus width */
#define PCMDRV_CFG_FLAFGS         0x000C /* little endian data format + no fast writes */

/* PC Master initialization */
#define PC_MASTER_REC_BUFF_LEN        0x2000 /* PC Matser Recorder buffer length */
#define PC_MASTER_APPCMD_BUFF_LEN     0x04 /* Application Command buffer length */
#define PC_MASTER_RECORDER_TIME_BASE  0x8030 /* A sampling period preset by the board application (value 0x8030 = 50us) */
#define PC_MASTER_GLOB_VERSION_MAJOR  0x05 /* Board firmware version major number */
#define PC_MASTER_GLOB_VERSION_MINOR  0x00 /* Board firmware version minor number */
#define PCMDRV_BUFFER_SIZE            0x80 /* Size of board data buffer */
#define PC_MASTER_IDT_STRING          "PC Master communication !" /* Identification string of the device */

/*------------------------------------------------------------------------------------------------------*/
/*                    structure with SCI communication settings                                         */
/*------------------------------------------------------------------------------------------------------*/
typedef struct {
	UInt8     *p_dataBuff;         /* pointer to input/output communication buffer */
	UInt8     dataBuffSize;        /* size of input/output communication buffer */
	UInt8     *p_recBuff;          /* pointer to recorder buffer */
	UWord16   recSize;             /* recorder buffer size */
	UInt8     *p_recorder;         /* structure with recorder settings and temporary variables */
	UInt8     *p_scope;            /* structure with scope settings */
	UWord16   timeBase;            /* period of Recorder Routine launch */
	UInt8     *p_appCmdBuff;       /* pointer to application command buffer */
	UInt8     appCmdSize;          /* application command buffer size */
	UInt8     globVerMajor;        /* board firmware version major number */
	UInt8     globVerMinor;        /* board firmware version minor number */
	UInt8     idtString[PCMDRV_IDT_STRING_LEN]; /* device identification string */
} sPCMasterComm;

/*------------------------------------------------------------------------------------------------------*/
/* recorder settings structure (recorder settings and temporary variables are stored in this structure) */
/*------------------------------------------------------------------------------------------------------*/
typedef struct{
	UWord16           cmd;
	UWord16           cmdLen;
	UWord16           trgMode;     /* 0x00 - manual, 0x01 - rising edge, 0x02 - falling edge   */
	UWord16           totalSmps;   /* number of samples required                               */
	UWord16           postTrigger; /* samples after trigger                                    */
	UWord16           timeDiv;     /* time div                                                 */
	UWord32           trgVarAddr[1]; /* address of trigger variable                              */
	UWord16           trgVarSize;  /* size of variable (bytes)                                 */
	UWord16           trgVarSigned; /* 0x00 - unsigned, 0x01 - signed                           */

	union{                         /* union is used to access various types of treshold        */
		UInt8           uch;         /* trgVarSize == 1                                          */
		Int8            ch;          /* trgVarSize == 1                                          */
		UWord16         uw;          /* trgVarSize == 2                                          */
		UWord32         ud;          /* trgVarSize == 2                                          */
		Word16          sw;          /* trgVarSize == 4                                          */
		Word32          sd;          /* trgVarSize == 4                                          */
	} trgThreshold;                /* trigger threshold                                        */

	UWord16           varCnt;      /* number of variables                                      */

	struct{
		UWord16         varSize;     /* size of variable                                         */
		UWord32         varAddr[1];  /* address of variable                                      */
	} varDef[8];

	UWord16           recPos;      /* position in recorder buffer - position of the next samples (incremented with RecSetLen) */
	UWord16           recSetLen;   /* length of required set of variables (in words) */
	UWord16           recToEnd;    /* position to end of buff (the variable is decremented after trigger & recorder stops at 0) */
	UWord16           recTime;     /* time div of Recorder */

	/* recorder last value (last value the triggering variable is stored after launch of Recorder routine)  */
	union{
		UInt8           uch;
		Int8            ch;
		UWord16         uw;
		UWord32         ud;
		Word16          sw;
		Word32          sd;
	} recLastVal;                  /* last value of synchronizing variable */
} pcmdrv_sRecorder;

/*------------------------------------------------------------------------------------------------------*/
/*                scope settings buffer (scope settings are stored in this structure)                   */
/*------------------------------------------------------------------------------------------------------*/
typedef struct{
	unsigned char varCnt;
	struct{
		UInt8 varSize;               /* size of scope variable */
		UInt8 addrByte[4];           /* address of scope variable */
	} varDef[8];                   /* maximum number of variables is 8 */
} pcmdrv_sScope;


/*--------------------------------------------------
define which commands will be compiled
--------------------------------------------------*/
#define PCMDRV_INCLUDE_CMD_SCOPE       /* read scope, setup scope */
#define PCMDRV_INCLUDE_CMD_RECORDER    /* setup recorder, get recorder buffer info,*/
/* start recorder, stop recorder get recorder status */
#define PCMDRV_INCLUDE_CMD_APPCMD      /* call app comd, app comd get status */
#undef PCMDRV_INCLUDE_CMD_GETINFOBRIEF /* enable getinfobrief command   */
/* (default = getinfo command)   */

/* call user application command status */
/* no application command called (board after reset) */
#define PCMDRV_APPCMD_NOCMD         0xFF
/* application command not finished */
#define PCMDRV_APPCMD_RUNNING       0xFE

/* status byte masks (used with 'status' variable) */
/* receiving started, beginning of message already detected ('+') */
#define ST_STARTED                0x0010
/* last received char was '+' */
#define ST_ST_CHAR_REC            0x0020
/* received message is standard command (for length decoding) */
#define ST_STD_CMD                0x0040
/* recorder is running (trigger already detected) */
#define ST_RECRUNNING             0x0100
/* recorder is activated (waiting for trigger) */
#define ST_RECACTIVATED           0x0200
/* read pretrigger samples before waiting for trigger */
#define ST_REC_READ_PRETRIG       0x0400
/* response is being send to PC */
#define ST_SENDING                0x1000
/* last sent char was '+' */
#define ST_ST_SENT                0x2000
/* checksum already added to the message */
#define ST_CS_ADDED               0x4000

#define START         '+'              /* start of message */

/* types of recorder trigger variables */
#define  REC_CHAR_UNSIGNED        0x0002
#define  REC_CHAR_SIGNED          0x0003
#define  REC_WORD_UNSIGNED        0x0004
#define  REC_WORD_SIGNED          0x0005
#define  REC_LONG_UNSIGNED        0x0008
#define  REC_LONG_SIGNED          0x0009

/*--------------------------------------
Macros
--------------------------------------*/
/* save data for response to PC */
#define respPrepare(sts, len) {response.status = sts; response.length = len;}

/* application command call status */
static unsigned char pcmdrvAppCmdSts;


#define Inhr7_OUT_BUF_SIZE  0x40       /* Length of the TX buffer */
static byte OutBuffer[Inhr7_OUT_BUF_SIZE];
static byte *OutPtrW = OutBuffer;

/******************************************************************************/
/*                      SCI MACROS - !!! core dependent !!!                   */
/******************************************************************************/
#define INT_DISABLE      0
#define INT_ENABLE       1
// #define SCIread(data) \
//           {Inhr7_RecvChar(&data);}
// #define SCIwrite(data) \
//           {Inhr7_SendChar(data);}
#define SCItxEmptyIsr(param) \
{if (param==INT_ENABLE) \
{PC_M1_SCITxEmptyInt = INT_ENABLE;}\
		 else if (param==INT_DISABLE) \
{PC_M1_SCITxEmptyInt = INT_DISABLE;} }
#define SCIrxFullIsr(param) \
{if (param==INT_ENABLE) \
{PC_M1_SCIRxFullInt = INT_ENABLE;}\
		 else if (param==INT_DISABLE) \
{PC_M1_SCIRxFullInt = INT_DISABLE;} }

/******************************************************************************/
/*                    MEMORY ACCESS - !!! core dependent !!!                  */
/******************************************************************************/
#define  POINT32_LEN    4
#define  BYTE_LEN       1
#define  WORD_LEN       2
#define  LONG_LEN       4

/********************************************************/
/* PC Master Communication protocol commands data types */
/********************************************************/

/* read variable */
typedef struct{
	unsigned char cmd;
	unsigned char addrByte[4];     /* address of variable */
} sReadVarEx;

/* response structure type (this structure is used to save
the parameters of response to be sent to PC) */
typedef struct{
	unsigned char status;          /* status byte of response */
	unsigned char length;          /* length of the whole response */
} sResponse;

/* standard commands */
/* read memory */
typedef struct{
	unsigned char cmd;
	unsigned char cmdLen;
	unsigned char size;            /* size of data block in bytes */
	unsigned char addrByte[4];     /* address of data */
} sReadMemEx;

/* write memory */
typedef struct{
	unsigned char cmd;
	unsigned char cmdLen;
	unsigned char size;            /* size of data block in bytes */
	unsigned char addrByte[4];     /* address of data */
	unsigned char data[1];         /* data */
} sWriteMemEx;

/* setup scope */
typedef struct{
	unsigned char cmd;
	unsigned char cmdLen;
	unsigned char varCnt;          /* number of variables */
	unsigned char dataByte[1];     /* address of variable */
} sSetupScopeEx;

/* setup recorder */
typedef struct{
	UWord16  cmd;
	UWord16  cmdLen;
	UWord16  trgMode;
	UWord16  totalSmps;
	UWord16  postTrigger;
	UWord16  timeDiv;              /* Time Base unit multiplier  */
	UWord32  trgVarAddr[1];
	UWord16  trgVarSize;
	UWord16  trgVarSigned;
	union {
		UInt8          uch;
		Int8           ch;
		UWord16        uw;
		Word16         sw;
		UWord32        ud;
		Word32         sd;
	} trgThreshold;                /* trigger comparing threshold */
	UWord16        varCnt;         /* number of variables */
	struct{
		UWord16     varSize;       /* size of variable in bytes */
		UWord32     varAddr[1];    /* address of variable    */
	} varDef[8];
} sSetupRec;

/* call user application command */
typedef struct{
	UInt8       cmd;
	UInt8       cmdLen;
	UInt8       appCmdData[1];     /* application command data */
} sCallAppCmd;

/* return any data */
typedef struct{
	unsigned char reserved;        /* status code */
	unsigned char data[1];         /* data to PC */
} sReturnData;

#define pcmasterdrvInit(sPCMasterComm) PC_M1_pcmasterdrvInit(sPCMasterComm)
Word16 PC_M1_pcmasterdrvInit(sPCMasterComm *p_sPCMasterComm);


/* currently read input char (it contains checksum at the end of message) */
static UInt8 inChar;
/* position in buffer (0,1,2,...) */
static unsigned short pos;
/* length of data in a message used for receiving and transmitting (includes checksum) */
static UInt8 length;

/* variable for checksum accumulation */
static unsigned short checkSum;

/* pointer to sciComm structure passed in initialization */
static sPCMasterComm *PCMasterComm;

static sResponse response;             /* variable with response data */

static UWord16 recPretrigCount;        /* recorder pretrigger counter   */

/* send one byte from output buffer */
static void sendBuffer(void);
/* prepare data for transmitting
(response.status -> status code, len -> length of data) */
static void sendResponse(sResponse *resp) ;
/* sample recorder data */
//static asm void readSample(int *Addr, int *DestAddr);
static UWord16 readRecSample(UWord16 position);
/* decoding of incoming message after the last byte was received */
static void messageDecode(void);

/* routine callled after filtering doubled SOM */
static void messageData(UWord16 startOfMessage);
/* all functions that begins with Cmd execute
the command and place the right data in dataBuff */
//__inline static void cmdGetInfoBrief(void);
static UWord16 memCopy(register volatile unsigned char * srcAddr,
					   register volatile unsigned char * destAddr,
					   register volatile signed char size);
/*---------------------------------------
SCI communication algotithm variables
--------------------------------------- */
static unsigned short status;            /* status word of receiver */


/*
** ===================================================================
**     Method      :  PC_M1_pcmasterdrvInit (bean PC_Master)
**
**     Description :
**         Initialization of PC Master Communication Algorithm. This
**         function must be called first, before start of
**         communication.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * p_sPCMasterComm - Pointer to
**                           structure with SCI communication
**                           settings.
**     Returns     :
**         ---             - The function returns the PASS (0).
** ===================================================================
*/
Word16 PC_M1_pcmasterdrvInit(sPCMasterComm *p_sPCMasterComm)
{
	/* store sPCMasterComm structure address */
	PCMasterComm=(sPCMasterComm *)p_sPCMasterComm;

	inChar = 1;
	status = 0; /* reset receiver */

#ifdef PCMDRV_INCLUDE_CMD_SCOPE
	/* reset scope */
	((pcmdrv_sScope *)(PCMasterComm->p_scope))->varCnt=0;
#endif

#ifdef PCMDRV_INCLUDE_CMD_RECORDER
	/* reset recorder */
	((pcmdrv_sScope *)(PCMasterComm->p_recorder))->varCnt=0;
#endif

#ifdef PCMDRV_INCLUDE_CMD_APPCMD
	/* initialize application command status */
	pcmdrvAppCmdSts = PCMDRV_APPCMD_NOCMD;
#endif

	return(0);
}

/*
** ===================================================================
**     Method      :  PC_M1_pcmasterdrvIsr (bean PC_Master)
**
**     Description :
**         Main PC Master Communication routine which provide
**         receiving, decoding of incoming message and sending
**         response to PC.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void PC_M1_pcmasterdrvIsr(void)
{
	if (status & ST_SENDING) {           /* message is transmitting */
		sendBuffer();                      /* send data */
		return;                            /* response is sending to PC */
	}
	if ((status & ST_ST_CHAR_REC) == 0) { /* last byte was not '+' */
		if (inChar == '+') {               /* '+' received */
			bitSet(ST_ST_CHAR_REC,status);
		}
		else {                             /* any byte received */
			messageData(0);                  /* byte received */
		}
	}
	else {                               /* the last byte was '+' */
		if (inChar == '+') {               /* doubled '+' (this is the second one) */
			messageData(0);                  /* byte received */
		}
		else {                             /* start of message */
			messageData(1);                  /* byte received */
		}
		bitClear(ST_ST_CHAR_REC,status);   /* clear flag */
	}
}


void PutChar(char c)
{
	inChar = c;
	if ((status & ST_ST_CHAR_REC) == 0) { /* last byte was not '+' */
		if (inChar == '+') {               /* '+' received */
			bitSet(ST_ST_CHAR_REC,status);
		}
		else {                             /* any byte received */
			messageData(0);                  /* byte received */
		}
	}
	else {                               /* the last byte was '+' */
		if (inChar == '+') {               /* doubled '+' (this is the second one) */
			messageData(0);                  /* byte received */
		}
		else {                             /* start of message */
			messageData(1);                  /* byte received */
		}
		bitClear(ST_ST_CHAR_REC,status);   /* clear flag */
	}
}

void PutData(const char * pAddress, short offset, short length)
{
	pAddress += offset;
	while(length--)
	{
		PutChar(*pAddress++);
	}
}


/*
** ===================================================================
**     Method      :  PC_M1_pcmasterdrvRecorder (bean PC_Master)
**
**     Description :
**         Recorder Routine. It performs sampling of data into
**         buffer which is located on the address p_recBuff item is
**         pointing and its length is determined by recSize item in
**         the initialization structure of sPCMasterComm type.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void PC_M1_pcmasterdrvRecorder(void)
{
	volatile union{
		UInt8      uch;
		Int8        ch;
		UWord16     uw;
		Word16      sw;
		UWord32     ud;
		Word32      sd;
	} actual;

	if (status & ST_RECACTIVATED) {      /* recorder activated */
		if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime ==
			((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->timeDiv) { /* now is the right time to make samples  */
				if (!(ST_REC_READ_PRETRIG & status)) {
					if (recPretrigCount >= (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->totalSmps -
						(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen *
						((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger)))
						bitSet(ST_REC_READ_PRETRIG, status);
					else recPretrigCount += ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen;
				}
				/* read actual trigger value  */
				memCopy((UInt8*)(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgVarAddr[0]),
					(UInt8*)(&actual.uch),(Int8)(((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize));
				/* read new samples  */
				((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recPos=
					readRecSample(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recPos );
				/* wrap around */
				if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recPos >=
					((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->totalSmps)
					((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recPos=0;
				switch (status & 0x000f) {
		  case REC_CHAR_UNSIGNED: {    /* size=1, unsigned char   */
			  if( (!(status & ST_RECRUNNING)) && (status & ST_REC_READ_PRETRIG) ) {
				  if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGRIS) &&
					  (actual.uch >= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uch) &&
					  (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.uch <
					  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uch)) {
						  /* recorder is configured to rising edge actual value       */
						  /* greater than threshold last value smaller than threshold */
						  bitSet(ST_RECRUNNING,status);
						  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
							  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger-1;
				  }
				  else
					  if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGFAL) &&
						  (actual.uch <= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uch) &&
						  (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.uch >
						  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uch)) {
							  /* recorder is configured to falling edge actual value      */
							  /* smaller than Threshold last value greater than Threshold */
							  bitSet(ST_RECRUNNING,status);
							  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
								  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger-1;
					  }
			  }
			  else
				  if(status & ST_REC_READ_PRETRIG)((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd--;
			  /* buffer is full */
			  if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd==0) {
				  bitClear(ST_RECRUNNING | ST_RECACTIVATED | ST_REC_READ_PRETRIG,status);
				  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd=1;
			  }
			  /* remember last value  */
			  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.uch = actual.uch;
			  /* reset recorder time  */
			  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime = 0;
								  }break;
		  case REC_CHAR_SIGNED: {      /* size=1,  signed  char   */
			  if( (!(status & ST_RECRUNNING)) && (status & ST_REC_READ_PRETRIG) ) {
				  if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGRIS) &&
					  (actual.ch >= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ch) &&
					  (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ch <
					  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ch)) {
						  /* recorder is configured to rising edge actual value       */
						  /* greater than threshold last value smaller than threshold */
						  bitSet(ST_RECRUNNING,status);
						  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
							  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger-1;
				  }
				  else
					  if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGFAL) &&
						  (actual.ch <= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ch) &&
						  (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ch >
						  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ch)) {
							  /* recorder is configured to falling edge actual value      */
							  /* smaller than Threshold last value greater than Threshold */
							  bitSet(ST_RECRUNNING,status);
							  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
								  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger-1;
					  }
			  }
			  else
				  if(status & ST_REC_READ_PRETRIG)((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd--;
			  /* buffer is full */
			  if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd==0) {
				  bitClear(ST_RECRUNNING | ST_RECACTIVATED | ST_REC_READ_PRETRIG,status);
				  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd=1;
			  }
			  /* remember last value  */
			  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ch = actual.ch;
			  /* reset recorder time  */
			  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime = 0;
								}break;
		  case REC_WORD_UNSIGNED: {    /* size=2, unsigned word  */
			  if( (!(status & ST_RECRUNNING)) && (status & ST_REC_READ_PRETRIG) ) {
				  if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGRIS) &&
					  (actual.uw >= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uw) &&
					  (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.uw <
					  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uw)) {
						  /* recorder is configured to rising edge actual value       */
						  /* greater than threshold last value smaller than threshold */
						  bitSet(ST_RECRUNNING,status);
						  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
							  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger-1;
				  }
				  else
					  if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGFAL) &&
						  (actual.uw <= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uw) &&
						  (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.uw >
						  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.uw)) {
							  /* recorder is configured to falling edge actual value      */
							  /* smaller than Threshold last value greater than Threshold */
							  bitSet(ST_RECRUNNING,status);
							  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
								  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger-1;
					  }
			  }
			  else
				  if(status & ST_REC_READ_PRETRIG)((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd--;
			  /* buffer is full */
			  if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd==0) {
				  bitClear(ST_RECRUNNING | ST_RECACTIVATED | ST_REC_READ_PRETRIG,status);
				  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd=1;
			  }
			  /* remember last value  */
			  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.uw = actual.uw;
			  /* reset recorder time   */
			  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime = 0;
								  }break;
		  case REC_WORD_SIGNED: {      /* size=2, signed word */
			  if( (!(status & ST_RECRUNNING)) && (status & ST_REC_READ_PRETRIG) ) {
				  if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGRIS) &&
					  (actual.sw >= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sw) &&
					  (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.sw <
					  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sw)) {
						  /* recorder is configured to rising edge actual value       */
						  /* greater than threshold last value smaller than threshold */
						  bitSet(ST_RECRUNNING,status);
						  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
							  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger-1;
				  }
				  else
					  if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGFAL) &&
						  (actual.sw <= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sw) &&
						  (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.sw >
						  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sw)) {
							  /* recorder is configured to falling edge actual value      */
							  /* smaller than Threshold last value greater than Threshold */
							  bitSet(ST_RECRUNNING,status);
							  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
								  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger-1;
					  }
			  }
			  else
				  if(status & ST_REC_READ_PRETRIG)((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd--;
			  /* buffer is full */
			  if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd==0) {
				  bitClear(ST_RECRUNNING | ST_RECACTIVATED | ST_REC_READ_PRETRIG,status);
				  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd=1;
			  }
			  /* remember last value  */
			  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.sw = actual.sw;
			  /* reset recorder time   */
			  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime = 0;
								}break;
		  case REC_LONG_UNSIGNED: {    /* size=4, unsigned double word  */
			  if( (!(status & ST_RECRUNNING)) && (status & ST_REC_READ_PRETRIG) ){
				  if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGRIS) &&
					  (actual.ud >= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ud) &&
					  (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ud <
					  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ud)) {
						  /* recorder is configured to rising edge actual value       */
						  /* greater than threshold last value smaller than threshold */
						  bitSet(ST_RECRUNNING,status);
						  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
							  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger-1;
				  }
				  else
					  if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGFAL) &&
						  (actual.ud <= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ud) &&
						  (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ud >
						  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.ud)) {
							  /* recorder is configured to falling edge actual value      */
							  /* smaller than Threshold last value greater than Threshold */
							  bitSet(ST_RECRUNNING,status);
							  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
								  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger-1;
					  }
			  }
			  else
				  if(status & ST_REC_READ_PRETRIG)((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd--;
			  /* buffer is full */
			  if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd==0) {
				  bitClear(ST_RECRUNNING | ST_RECACTIVATED | ST_REC_READ_PRETRIG,status);
				  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd=1;
			  }
			  /* remember last value  */
			  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ud = actual.ud;
			  /* reset recorder time   */
			  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime = 0;
								  }break;
		  case REC_LONG_SIGNED: {      /* size=4,   signed double word  */
			  if( (!(status & ST_RECRUNNING)) && (status & ST_REC_READ_PRETRIG) ) {
				  if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGRIS) &&
					  (actual.sd >= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sd) &&
					  (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.sd <
					  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sd)) {
						  /* recorder is configured to rising edge actual value       */
						  /* greater than threshold last value smaller than threshold */
						  bitSet(ST_RECRUNNING,status);
						  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
							  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger-1;
				  }
				  else
					  if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgMode == PCMDRV_REC_TRIGFAL) &&
						  (actual.sd <= ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sd) &&
						  (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.sd >
						  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgThreshold.sd)) {
							  /* recorder is configured to falling edge actual value      */
							  /* smaller than Threshold last value greater than Threshold */
							  bitSet(ST_RECRUNNING,status);
							  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd =
								  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger-1;
					  }
			  }
			  else
				  if(status & ST_REC_READ_PRETRIG)((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd--;
			  /* buffer is full */
			  if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd==0) {
				  bitClear(ST_RECRUNNING | ST_RECACTIVATED | ST_REC_READ_PRETRIG,status);
				  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd=1;
			  }
			  /* remember last value  */
			  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.sd = actual.sd;
			  /* reset recorder time   */
			  ((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime = 0;
								}break;
				}
		}
		else {
			((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime++;
		}
	}
	else {                               /* recorder not activated */
		recPretrigCount = 0;
		bitClear(ST_REC_READ_PRETRIG, status);
	}
}

/*
** ===================================================================
**     Method      :  memCopy (bean PC_Master)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static UWord16 memCopy(register volatile char unsigned *srcAddr,
					   register volatile unsigned char *destAddr,
					   register volatile signed char size)
{
	while ((--size) >= 0) {
		*destAddr++ = *srcAddr++;
	}
	return(0);
}

/*
** ===================================================================
**     Method      :  sendBuffer (bean PC_Master)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
__inline static void sendBuffer(void)
{
	if (pos <= length) {                 /* is it end of message ? */
		//Inhr7_SendChar((PCMasterComm)->p_dataBuff[pos]); /* send one char to SCI */
		if ((PCMasterComm)->p_dataBuff[pos] != '+') { /* current character is not '+' */
			checkSum += (PCMasterComm)->p_dataBuff[pos]; /* accumulate checksum */
			pos++;
		}
		else {                             /* current character is '+' */
			if (status & ST_ST_SENT) {       /* the last sent char was '+' */
				bitClear(ST_ST_SENT,status);
				checkSum += (PCMasterComm)->p_dataBuff[pos]; /* accumulate checksum */
				pos++;
			}
			else {                           /* the last sent byte was not '+' */
				bitSet(ST_ST_SENT,status);
			}
		}
		if ((pos == length) && !(status & ST_CS_ADDED)) { /* the last byte before cs was sent, now add the checksum */
			checkSum = (-checkSum) & 0x00FF; /* compute checksum */
			(PCMasterComm)->p_dataBuff[pos] = (UInt8)checkSum;
			bitSet(ST_CS_ADDED,status);      /* set flag */
		}
	}
	else {                               /* end of transmitting */
		bitClear(ST_SENDING | ST_CS_ADDED,status); /* reset transmitter (switch to receiving mode) */
	}
}
typedef void (*fptr_printf)(const char *buffer, UInt32 size);
static fptr_printf fprint = NULL;

static void sendResponse(sResponse *pRespones)
{
	int add_length = 0;
	(PCMasterComm)->p_dataBuff[0] = pRespones->status;
	length = pRespones->length;
	if(pRespones->length > 10)
	{
		length = pRespones->length;
	}
	pos = 0;
	checkSum = 0;
	*OutPtrW++ = '+';

	while (length--)
	{
		*OutPtrW++ = (PCMasterComm)->p_dataBuff[pos];
		if((PCMasterComm)->p_dataBuff[pos] == 0x2b)
		{
			*OutPtrW++ = 0x2b;
			add_length++;
		}
		checkSum += (PCMasterComm)->p_dataBuff[pos];
		pos++;
	}
	checkSum = (-checkSum) & 0x00ff;
	*OutPtrW++ = checkSum;
	if(checkSum == 0x2b)
	{
		*OutPtrW++ = 0x2b;
		add_length++;
	}

	OutPtrW = OutBuffer;

	if(NULL != fprint)
	{
		fprint((char *)OutBuffer, pRespones->length + 2 + add_length);	  //1+1checksum
	}
}

/*
** ===================================================================
**     Method      :  messageDecode (bean PC_Master)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void messageDecode(void)
{
	unsigned char *varaddr;
#ifndef PCMDRV_INCLUDE_CMD_GETINFOBRIEF
	unsigned char cnt;
#endif

	switch(PCMasterComm->p_dataBuff[0]) {
		/* -------------------------
		special format commands
		------------------------- */
	case PCMDRV_CMD_READVAR8EX: {      /* read 8-bit variable */
		/* read address */
		memCopy(((sReadVarEx *)(PCMasterComm->p_dataBuff))->addrByte,
			(unsigned char *)&varaddr, POINT32_LEN);
		/* read data */
		memCopy(varaddr, ((sReturnData *)(PCMasterComm->p_dataBuff))->data, BYTE_LEN);
		respPrepare(PCMDRV_STC_OK, 2); /* OK */
								}break;
	case PCMDRV_CMD_READVAR16EX: {     /* read 16-bit variable */
		/* read address */
		memCopy(((sReadVarEx *)(PCMasterComm->p_dataBuff))->addrByte,
			(unsigned char *)&varaddr, POINT32_LEN);
		/* read data */
		memCopy(varaddr, ((sReturnData *)(PCMasterComm->p_dataBuff))->data, WORD_LEN);
		respPrepare(PCMDRV_STC_OK, 3); /* OK */
								 }break;
	case PCMDRV_CMD_READVAR32EX: {     /* read 32-bit variable */
		/* read address */
		memCopy(((sReadVarEx *)(PCMasterComm->p_dataBuff))->addrByte,
			(unsigned char *)&varaddr, POINT32_LEN);
		/* read data */
		memCopy(varaddr, ((sReturnData *)(PCMasterComm->p_dataBuff))->data, LONG_LEN);
		respPrepare(PCMDRV_STC_OK, 5); /* OK */
								 }break;
#ifdef PCMDRV_INCLUDE_CMD_SCOPE
	case PCMDRV_CMD_READSCOPE: {       /* read scope variables */
		unsigned char i, cnt, index = 0;
		/* scope not configured */
		if (((pcmdrv_sScope *)(PCMasterComm->p_scope))->varCnt==0) {
			respPrepare(PCMDRV_STC_NOTINIT,1); /* scope not initialized */
		}
		else {                         /* scope configured */
			/* read number of variables */
			cnt = ((pcmdrv_sScope *)(PCMasterComm->p_scope))->varCnt;
			for (i=0; i < cnt; i++) {
				/* read size of variable */
				length = ((pcmdrv_sScope *)(PCMasterComm->p_scope))->varDef[i].varSize;
				/* read address of variable */
				memCopy( ((pcmdrv_sScope *)(PCMasterComm->p_scope))->varDef[i].addrByte,
					(unsigned char *)&varaddr, POINT32_LEN);
				/* copy data into the input/output buffer */
				memCopy( varaddr, (unsigned char *)&((sReturnData *)
					(PCMasterComm->p_dataBuff))->data[index], (Int8) length);
				index += length;
			}
			respPrepare(PCMDRV_STC_OK, (UInt8)(index +1)); /* OK */
		}
							   }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_APPCMD
	case PCMDRV_CMD_GETAPPCMDSTS: {    /* get user application command call status */
		/* buffer is not initialized (zero length) */
		if (PCMasterComm->appCmdSize == 0) {
			respPrepare(PCMDRV_STC_INVCMD,1); /* invalid command */
			return;
		}
		/* copy status byte in the output buffer */
		((sReturnData *)(PCMasterComm->p_dataBuff))->data[0] = pcmdrvAppCmdSts;
		respPrepare(PCMDRV_STC_OK,2);   /* OK */
								  }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_GETINFOBRIEF
	case PCMDRV_CMD_GETINFOBRIEF: {    /* get brief info about hardware */
		cmdGetInfoBrief();             /* execute the command */
		respPrepare(PCMDRV_STC_OK,(1 + 6)); /* OK */
								  }break;
#endif
#ifndef PCMDRV_INCLUDE_CMD_GETINFOBRIEF
	case PCMDRV_CMD_GETINFO: {         /* get info about hardware */
		/* protocol version  */
		((sReturnData *)(PCMasterComm->p_dataBuff))->data[0] = PCMDRV_PROT_VER;
		/* CFG_FLAFGS  */
		((sReturnData *)(PCMasterComm->p_dataBuff))->data[1] = PCMDRV_CFG_FLAFGS;
		/* dataBusWdt  */
		((sReturnData *)(PCMasterComm->p_dataBuff))->data[2] = PCMDRV_DATABUSWDT;
		/* version  */
		((sReturnData *)(PCMasterComm->p_dataBuff))->data[3] = PCMasterComm->globVerMajor;
		/* version  */
		((sReturnData *)(PCMasterComm->p_dataBuff))->data[4] = PCMasterComm->globVerMinor;
		/* size of input buffer (without CMD, LENGTH)   */
		((sReturnData *)(PCMasterComm->p_dataBuff))->data[5] = (UInt8)(((PCMasterComm->dataBuffSize) - 1));
		/* recorder buff size   */
		((sReturnData *)(PCMasterComm->p_dataBuff))->data[6] = (UInt8)((PCMasterComm->recSize )      & 0x00ff);
		((sReturnData *)(PCMasterComm->p_dataBuff))->data[7] = (UInt8)(((PCMasterComm->recSize)>>8)  & 0x00ff);
		/* period of Recorder routine launch   */
		((sReturnData *)(PCMasterComm->p_dataBuff))->data[8] = (UInt8)((PCMasterComm->timeBase)      & 0x00ff);
		((sReturnData *)(PCMasterComm->p_dataBuff))->data[9] = (UInt8)(((PCMasterComm->timeBase)>>8) & 0x00ff);
		/* copy identification string */
		for (cnt=0 ; cnt < PCMDRV_IDT_STRING_LEN ; cnt++) {
			((sReturnData *)((PCMasterComm)->p_dataBuff))->data[10 + cnt] = PCMasterComm->idtString[cnt];
		}
		/* OK */
		respPrepare(PCMDRV_STC_OK,(1 + 10 + PCMDRV_IDT_STRING_LEN));
							 }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_RECORDER
	case PCMDRV_CMD_STARTREC: {        /* start recorder */
		if (PCMasterComm->recSize==0) { /* recorder not implemented  */
			respPrepare(PCMDRV_STC_INVCMD,1); /* invalid command */
			return;
		}
		if(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) { /* recorder initialized      */
			if (!(status & ST_RECRUNNING)) { /* recorder not running      */
				bitClear(ST_RECRUNNING,status); /* stop recorder if it is running   */
				(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime) = /* initialize time div       */
					((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->timeDiv; /* addr. of triggering variable  */
				varaddr=(unsigned char*)(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgVarAddr);
				memCopy((UInt8*)(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgVarAddr[0]),
					(UInt8*)(&(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ud)),
					(Int8)(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgVarSize));
				bitSet(ST_RECACTIVATED,status); /* activate recorder to wait for trigger */
				respPrepare(PCMDRV_STC_OK,1); /* OK */
			}
			else {
				respPrepare(PCMDRV_STC_RECRUN,1); /* recorder is running  */
			}
		}
		else {                         /* recorder is not initialized   */
			respPrepare(PCMDRV_STC_NOTINIT,1); /* recorder not initialized   */
		}
							  }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_RECORDER /* start recorder */
	case PCMDRV_CMD_STOPREC: {         /* stop recorder  */
		if (PCMasterComm->recSize==0) { /* recorder not implemented   */
			respPrepare(PCMDRV_STC_INVCMD,1); /* invalid command   */
			return;
		}
		if (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) { /* recorder initialized */
			if (status & ST_RECACTIVATED) { /* recorder activated   */
				if (status & ST_RECRUNNING) { /* recorder running     */
					respPrepare(PCMDRV_STC_RECDONE,1); /* recorder finished    */
				}
				else {                     /* recorder not running */
					/* initialize posttrigger value  */
					(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd)=
						(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->postTrigger);
					bitSet(ST_RECRUNNING,status); /* manually trigger the recorder */
					respPrepare(PCMDRV_STC_OK,1); /* OK */
				}
			}
			else {                       /* recorder not activated  */
				respPrepare(PCMDRV_STC_RECDONE,1); /* recorder finished       */
			}
		}
		else {                         /* recorder not initialized*/
			respPrepare(PCMDRV_STC_NOTINIT,1);
		}
							 }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_RECORDER /* start recorder          */
	case PCMDRV_CMD_GETRECBUFFEX: {    /* get recorder buffer     */
		UWord16        tmp;            /* temporary variable      */

		if (PCMasterComm->recSize==0) { /* recorder not implemented*/
			respPrepare(PCMDRV_STC_INVCMD,1);
			return;
		}
		if ((((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) != 0) { /* recorder initialized */
			if (!(status & ST_RECRUNNING)) { /* recorder not running */
				/* recorder buffer address */
				memCopy((UInt8*)(&(PCMasterComm->p_recBuff)),(UInt8*)(&(PCMasterComm->p_dataBuff[1])),LONG_LEN);
				tmp=(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recPos)/
					(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen);
				(PCMasterComm)->p_dataBuff[5]= (UInt8)(tmp & 0x00FF); /* position of the last sample in rec.buff. LSB */
				(PCMasterComm)->p_dataBuff[6]= (UInt8)(tmp >> 8); /* position of the last sample in rec.buff. MSB */
				respPrepare(PCMDRV_STC_OK,7); /* OK */
			}
			else {                       /* recorder running  */
				respPrepare(PCMDRV_STC_SERVBUSY,1); /*  service busy     */
			}
		}
		else {                         /* recorder initialized */
			respPrepare(PCMDRV_STC_NOTINIT,1); /* recorder not initialized   */
		}
								  }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_RECORDER /* recorder status            */
	case PCMDRV_CMD_GETRECSTS: {       /* get recorder status        */
		if (PCMasterComm->recSize==0) { /* recorder not implemented   */
			respPrepare(PCMDRV_STC_INVCMD,1); /* invalid command            */
			return;
		}
		if (((pcmdrv_sScope *)(PCMasterComm->p_recorder))->varCnt) { /* recorder is initialized    */
			if (!(status & ST_RECACTIVATED)) {
				respPrepare(PCMDRV_STC_RECDONE,1); /* recorder finished          */
			}
			else {
				respPrepare(PCMDRV_STC_RECRUN,1); /* recorder running           */
			}
		}
		else {                         /* recorder is not initialized*/
			respPrepare(PCMDRV_STC_NOTINIT,1); /* recorder not initialized   */
		}
							   }break;
#endif
		/* --------------------------
		standard format commands
		-------------------------- */
#ifdef PCMDRV_INCLUDE_CMD_SCOPE
	case PCMDRV_CMD_SETUPSCOPEEX: {    /* setup scope */
		unsigned char cnt,i;

		cnt = (((sSetupScopeEx *)(PCMasterComm->p_dataBuff))->varCnt);
		if ( (cnt == 0) || (cnt > 8) ) {
			/* varCnt is zero or greater than 8 */
			respPrepare(PCMDRV_STC_INVBUFF,1); /* invalid buffer size */
			return;
		}
		/* read varCnt */
		((pcmdrv_sScope *)(PCMasterComm->p_scope))->varCnt = cnt;
		for (i=0; i < cnt; i++) {
			/* read size of variable */
			((pcmdrv_sScope *)(PCMasterComm->p_scope))->varDef[i].varSize =
				((sSetupScopeEx *)(PCMasterComm->p_dataBuff))->dataByte[i*5];
			/* read address of variable */
			memCopy( (unsigned char *)&((sSetupScopeEx *)
				(PCMasterComm->p_dataBuff))->dataByte[1 + 5*i],
				((pcmdrv_sScope *)(PCMasterComm->p_scope))->
				varDef[i].addrByte, POINT32_LEN);
		}
		/* check size of variable s */
		for(i=0 ; i<(((pcmdrv_sScope *)(PCMasterComm->p_scope))->varCnt) ; i++) {
			/* varSize is 0,3 or greater than 4 */
			if ( ((((pcmdrv_sScope *)(PCMasterComm->p_scope))->varDef[i].varSize) == 0) || \
				((((pcmdrv_sScope *)(PCMasterComm->p_scope))->varDef[i].varSize) == 3) || \
				((((pcmdrv_sScope *)(PCMasterComm->p_scope))->varDef[i].varSize) > 4) ) {
					/* invalid size of variable */
					respPrepare(PCMDRV_STC_INVSIZE,1);
					/* reset scope */
					(((pcmdrv_sScope *)(PCMasterComm->p_scope))->varCnt) = 0;
					return;
			}
		}
		respPrepare(PCMDRV_STC_OK,1);
								  }break;
#endif
#ifdef PCMDRV_INCLUDE_CMD_RECORDER
	case PCMDRV_CMD_SETUPRECEX: {
		unsigned char i;               /* auxiliariy variables definition   */

		if (PCMasterComm->recSize==0) { /* recorder not implemented  */
			respPrepare(PCMDRV_STC_INVCMD,1); /* invalid command  */
			return;
		}
		/* reset the recorder */
		bitClear(ST_RECRUNNING | ST_RECACTIVATED,status);
		/* initialize recorder*/
		/* (copy data from dataBuff to Recorder structure) => copy structure form PCMasterComm->p_dataBuff to */
		/* PCMasterComm->p_recorder =>  copy and organize data  to recorder structure. It is necessary to do  */
		/* conversions byte variables to word by reason of arrange data to even address                       */
		/* read command             */
		((sSetupRec *)(PCMasterComm->p_recorder))->cmd     = *((PCMasterComm->p_dataBuff)+0);
		/* read cmdLen              */
		((sSetupRec *)(PCMasterComm->p_recorder))->cmdLen  = *((PCMasterComm->p_dataBuff)+1);
		/* read trigger mode        */
		((sSetupRec *)(PCMasterComm->p_recorder))->trgMode = *((PCMasterComm->p_dataBuff)+2);
		if( ((sSetupRec *)(PCMasterComm->p_recorder))->trgMode > 2 ) { /* test value {0,1,2}       */
			respPrepare(PCMDRV_STC_INVBUFF,1); /* invalid trigger mode     */
			return;
		}
		/* read total samples        */
		memCopy((PCMasterComm->p_dataBuff)+3,
			(UInt8*)(&(((sSetupRec *)(PCMasterComm->p_recorder))->totalSmps)),WORD_LEN);
		/* read post tiger size      */
		memCopy((PCMasterComm->p_dataBuff)+5,
			(UInt8*)(&(((sSetupRec *)(PCMasterComm->p_recorder))->postTrigger)),WORD_LEN);
		/* read timeDiv             */
		memCopy((PCMasterComm->p_dataBuff)+7,
			(UInt8*)(&(((sSetupRec *)(PCMasterComm->p_recorder))->timeDiv)),WORD_LEN);
		/* read trig. variab. address*/
		memCopy((PCMasterComm->p_dataBuff)+9,
			(UInt8*)(&(((sSetupRec *)(PCMasterComm->p_recorder))->trgVarAddr[0])),POINT32_LEN);
		/* read trig. variab. size   */
		((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize       = *((PCMasterComm->p_dataBuff)+13);
		if(!((((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize==1) || /* test trig. variab. size   */
			(((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize==2) ||
			(((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize==4))) {
				respPrepare(PCMDRV_STC_INVSIZE,1); /* invalid buffer size       */
				(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) =  0;
				return;
		}
		/* read trig. compare mode    */
		((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSigned     = *((PCMasterComm->p_dataBuff)+14);
		memCopy((PCMasterComm->p_dataBuff)+15,
			(UInt8*)(&(((sSetupRec *)(PCMasterComm->p_recorder))->trgThreshold.ud)),LONG_LEN);
		/* read variable definitions  */
		((sSetupRec *)(PCMasterComm->p_recorder))->varCnt           = *((PCMasterComm->p_dataBuff)+19);
		if ( (((sSetupRec *)(PCMasterComm->p_recorder))->varCnt == 0) || /* testing of data correctness*/
			(((sSetupRec *)(PCMasterComm->p_recorder))->varCnt > 8) ) {
				respPrepare(PCMDRV_STC_INVBUFF,1); /* if varCnt is zero or greater than 8 => invalid buffer size */
				(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) =  0;
				return;
		}
		status = (status & 0xfff0) | ((((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize)<<1) +
			((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSigned; /* set status                 */
		for(i=0;i<((sSetupRec *)(PCMasterComm->p_recorder))->varCnt;i++) { /* data descriptions => scope */
			/* initialization             */
			/* read variable size         */
			((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varSize = *((PCMasterComm->p_dataBuff)+20+i*5);
			if((((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varSize==0) ||
				(((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varSize==3)) { /* test variable sizes        */
					respPrepare(PCMDRV_STC_INVSIZE,1); /* invalid buffer size        */
					(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) =  0;
					return;
			}
			memCopy((PCMasterComm->p_dataBuff)+21+i*5,
				(UInt8*)(&(((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varAddr[0])),POINT32_LEN);
		}
		/*  next samples position in recorder buffer - incremented by RecSetLen */
		status = (status & 0xfff0) | ((((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSize)<<1) +
			((sSetupRec *)(PCMasterComm->p_recorder))->trgVarSigned; /* set status                 */
		((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recPos = 0;
		/*  length of requiered variables set [Word] */
		((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen =   0;
		/*  position to end of buffer */
		((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recToEnd  =   1;
		/*  recorder time div         */
		((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recTime   =
			((sSetupRec *)(PCMasterComm->p_recorder))->timeDiv;
		/* check if recorder buffer size is valid */
		((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen = 0; /* clear result before cycle  */
		for(i=0;i<((sSetupRec *)(PCMasterComm->p_recorder))->varCnt;i++) { /* get one set of samples [B] */
			((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen +=
				((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varSize;
		}
		((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->totalSmps *= /* required buffer size [W]   */
			((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recSetLen;
		if(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->totalSmps <= /* required buffer size is    */
			PCMasterComm->recSize) { /* smaller than record. buffer*/
				/* read last value of trig. variable   */
				memCopy((UInt8*)(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgVarAddr[0]),
					(UInt8*)(&(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->recLastVal.ud)),
					(Int8)(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->trgVarSize));
				respPrepare(PCMDRV_STC_OK,1);
				bitSet(ST_RECACTIVATED,status); /* recorder activated  */
		}
		else {
			respPrepare(PCMDRV_STC_INVSIZE,1); /* invalid buffer size */
			(((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) =  0;
			return;
		}
								}break;
#endif
	case PCMDRV_CMD_READMEMEX: {       /* read block of memory */
		/* read size of data */
		memCopy(&(((sReadMemEx *)(PCMasterComm->p_dataBuff))->size),
			(unsigned char *)&length, BYTE_LEN);
		if (length <= ((PCMasterComm)->dataBuffSize)) {
			/* read address */
			memCopy(((sReadMemEx *)(PCMasterComm->p_dataBuff))->addrByte,
				(unsigned char *)&varaddr, POINT32_LEN);
			/* copy data */
			memCopy( varaddr,(((sReturnData *)(PCMasterComm->p_dataBuff))->data),(Int8) length);
			respPrepare(PCMDRV_STC_OK,(UInt8)(length+1)); /* OK */
		}
		else {
			/* response greater than buffer */
			/* response buffer overflow */
			respPrepare(PCMDRV_STC_RSPBUFFOVF,1);
		}
							   }break;
	case PCMDRV_CMD_WRITEMEMEX: {      /* write block of memory */
		/* read length of memory block from the message */
		memCopy(&(((sWriteMemEx *)(PCMasterComm->p_dataBuff))->size),
			(unsigned char *)&length, BYTE_LEN);
		/* read address */
		memCopy((((sWriteMemEx *)(PCMasterComm->p_dataBuff))->addrByte),
			(unsigned char *)&varaddr, POINT32_LEN);
		/* copy data */
		memCopy((((sWriteMemEx *)(PCMasterComm->p_dataBuff))->data),
			varaddr, (Int8)length);
		respPrepare(PCMDRV_STC_OK,1);
								}break;
	case PCMDRV_CMD_WRITEMEMMASKEX: {  /* write to memory with mask */
		unsigned char i, tmpData;

		/* read length of memory block from the message */
		memCopy(&(((sWriteMemEx *)(PCMasterComm->p_dataBuff))->size),
			(unsigned char *)&length, BYTE_LEN);
		/* read address */
		memCopy((((sWriteMemEx *)(PCMasterComm->p_dataBuff))->addrByte),
			(unsigned char *)&varaddr, POINT32_LEN);
		for (i=0; i<length; i++) {
			/* read data */
			tmpData =  ((sWriteMemEx *)(PCMasterComm->p_dataBuff))->data[i]; /* read data */
			tmpData &= ((sWriteMemEx *)(PCMasterComm->p_dataBuff))->data[i + length]; /* read mask */
			//          archDisableInt();
			tmpData |= (*varaddr) & ~(((sWriteMemEx *)(PCMasterComm->p_dataBuff))->data[i + length]);
			*varaddr = tmpData;          /* write back modified data */
			//          archEnableInt();
		}
		respPrepare(PCMDRV_STC_OK,1);  /* OK */
									}break;
#ifdef PCMDRV_INCLUDE_CMD_APPCMD
	case PCMDRV_CMD_CALLAPPCMD: {      /* call user application command */
		if (PCMasterComm->appCmdSize == 0) { /* buffer is not initialized (zero length) */
			respPrepare(PCMDRV_STC_INVCMD,1); /* invalid command */
			break;
		}
		memCopy( (unsigned char *)&(((sCallAppCmd *)(PCMasterComm->p_dataBuff))->cmdLen),
			(unsigned char *)&length, BYTE_LEN);
		if ( length > PCMasterComm->appCmdSize) { /* check Application Command length */
			respPrepare(PCMDRV_STC_INVBUFF,1); /* invalid buffer size */
		}
		else {
			if (pcmdrvAppCmdSts == PCMDRV_APPCMD_RUNNING) { /* Application Command already called */
				respPrepare(PCMDRV_STC_SERVBUSY,1); /* service is busy  */
			}
			else {                       /* no Application Command was called */
				/* copy Application Command data to Application Command buffer */
				memCopy( (((sCallAppCmd *)(PCMasterComm->p_dataBuff))->appCmdData),
					PCMasterComm->p_appCmdBuff,(Int8) length);
				pcmdrvAppCmdSts = PCMDRV_APPCMD_RUNNING;
				respPrepare(PCMDRV_STC_OK,1); /* OK */
			}
		}
								}break;
#endif
	default: {                         /* invalid command */
		respPrepare(PCMDRV_STC_INVCMD,1); /* invalid command */
			 }break;
	}
}

/*
** ===================================================================
**     Method      :  messageData (bean PC_Master)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void messageData(UWord16 startOfMessage)
{
	if (startOfMessage == 0) {           /* no start of message */
		if (status & ST_STARTED) {         /* start of message already detected */
			if (pos != length) {             /* read byte, accumulate checksum */
				(PCMasterComm)->p_dataBuff[pos] = (UInt8)inChar;
				checkSum += inChar;            /* checksum accumulation */
				pos++;                         /* next position in buffer */
				if (status & ST_STD_CMD) {     /* inChar contains length of standard format message */
					length = (UInt8)(inChar + 2); /* read length of message */
					bitClear(ST_STD_CMD,status); /* clear flag */
					if (length > ((PCMasterComm)->dataBuffSize)) { /* command is greater than input buffer */
						/* clear flag */
						bitClear(ST_STARTED | ST_ST_CHAR_REC,status);
						/* input buffer overflow */
						respPrepare(PCMDRV_STC_CMDBUFFOVF,1);
						/* send response to PC */
						sendResponse(&response);
					}
				}
			}
			else {                           /* end of message */
				checkSum += inChar;            /* accumulate checksum */
				if ((checkSum & 0x00FF) == 0) { /* correct checksum */
					messageDecode();
				}
				else {                         /* checksum error */
					/* checksum error response */
					respPrepare(PCMDRV_STC_CMDSERR,1);
				}
				/* clear flag */
				bitClear(ST_STARTED | ST_ST_CHAR_REC,status);
				sendResponse(&response);       /* send response to PC */
			}
		}
	}
	else {                               /* start of message */
		/* reset receiver, read first byte of message */
		bitSet(ST_STARTED,status);         /* message receiving */
		/* read byte, start of checksum accumulating */
		checkSum = (PCMasterComm)->p_dataBuff[0] = (UInt8)inChar;
		/* next position in buffer */
		pos = 1;
		/* value sufficient for standard format commands */
		length = 2;
		if (inChar >= 0xC0) {              /* special format command */
			length=(UInt8)(((inChar & 0x30) >> 3) + 1); /* length decoding */
		}
		else {                             /* standard format command (next byte will be length of the message) */
			bitSet(ST_STD_CMD,status);       /* wait for next character */
		}
	}
}

/*
** ===================================================================
**     Method      :  readRecSample (bean PC_Master)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static UWord16 readRecSample(UWord16 position)
{
	Word16 i;

	for (i=0 ; i < (((pcmdrv_sRecorder *)(PCMasterComm->p_recorder))->varCnt) ; i++) { /* read each variable */
		/* read each variable */
		memCopy((UInt8*)(((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varAddr[0]),
			(UInt8*)((PCMasterComm->p_recBuff)+position),
			(Int8)(((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varSize));
		position += ((sSetupRec *)(PCMasterComm->p_recorder))->varDef[i].varSize;
	}
	return(position);
}

/*
** ===================================================================
**     Method      :  PC_M1_PE_Init (bean PC_Master)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
sReturnData * returnData;
pcmdrv_sRecorder * pPcmdrvRecorder;
pcmdrv_sScope *  pPcmdrvScope;

void PC_M1_PE_Init(void)
{
#if !defined(PCMDRV_BUFFER_SIZE)
#define PCMDRV_BUFFER_SIZE                         60
#endif

#if !defined(PC_MASTER_REC_BUFF_LEN)
	/* Recorder buffer length */
#define PC_MASTER_REC_BUFF_LEN                     40
#endif
#if !defined(PC_MASTER_APPCMD_BUFF_LEN)
	/* Application Command buffer length */
#define PC_MASTER_APPCMD_BUFF_LEN                   5
#endif


	static word pcmdrvDataBuff[(PCMDRV_BUFFER_SIZE / 2) + 1];
	static sPCMasterComm PCMSettings;    /* initialization structure */
	static pcmdrv_sScope pcmdrvScope;    /* scope config data */

#if (PC_MASTER_REC_BUFF_LEN != 0)
	/* recorder buffer */
	//static UWord16 PCMasterCommRecorderBuffer[PC_MASTER_REC_BUFF_LEN];
	static pcmdrv_sRecorder pcmdrvRecorder; /* recorder config and temp data */
#endif
#if (PC_MASTER_APPCMD_BUFF_LEN != 0)
	/* application command data buffer */
	static unsigned char PCMasterAppCmdBuff[PC_MASTER_APPCMD_BUFF_LEN];
#endif
#if (PC_MASTER_REC_BUFF_LEN != 0)
	/* address of buffer */
	PCMSettings.p_recBuff   = (unsigned char *)rt_malloc(PC_MASTER_REC_BUFF_LEN*2);//(unsigned char *)PCMasterCommRecorderBuffer;
	PCMSettings.p_recorder  = (unsigned char *)&pcmdrvRecorder;
	pPcmdrvRecorder = &pcmdrvRecorder;
	returnData = (sReturnData * )PCMasterComm->p_dataBuff;
	pPcmdrvScope = &pcmdrvScope;
#endif

	/* address of input/output buffer */
	PCMSettings.p_dataBuff   = (unsigned char *)pcmdrvDataBuff;
	PCMSettings.dataBuffSize = PCMDRV_BUFFER_SIZE;
	/* buffer length */
	PCMSettings.recSize      = PC_MASTER_REC_BUFF_LEN;
	/* recorder time base */
	PCMSettings.timeBase     = PC_MASTER_RECORDER_TIME_BASE ;

#if (PC_MASTER_APPCMD_BUFF_LEN != 0)
	/* address of buffer */
	PCMSettings.p_appCmdBuff = PCMasterAppCmdBuff;
#endif

	PCMSettings.p_scope      = (unsigned char *)&pcmdrvScope;
	/* buffer length */
	PCMSettings.appCmdSize   = PC_MASTER_APPCMD_BUFF_LEN;
	/* board firmware version major number */
	PCMSettings.globVerMajor = PC_MASTER_GLOB_VERSION_MAJOR;
	/* board firmware version minor number */
	PCMSettings.globVerMinor = PC_MASTER_GLOB_VERSION_MINOR;
	/* device identification string */
	strcpy((char *)PCMSettings.idtString,PC_MASTER_IDT_STRING);
	/* SCI communication initialization */
	pcmasterdrvInit(&PCMSettings);
}

void SetTxApi( void *print )
{
	fprint = (fptr_printf)print;
}

struct rt_semaphore sem_fmrecord_10ms;
static void rt_thread_entry_freemaster(void* parameter)
{
	rt_sem_init(&sem_fmrecord_10ms,   "Sem_fm",    0,  RT_IPC_FLAG_FIFO);
	//----------------------------------------------------------
	// ³õÊ¼»¯freemaster
	//----------------------------------------------------------
	PC_M1_PE_Init();
	SetTxApi((void*)freemaster_txapi);

	for(;;)
	{
		rt_sem_take(&sem_fmrecord_10ms, RT_WAITING_FOREVER);

		PC_M1_pcmasterdrvRecorder();
	}
}

void freemaster_txapi(const char *ptr, int size)
{
	/* write data directly */
	while (size)
	{
		while (!(USART1->SR & USART_FLAG_TXE));
		USART1->DR = (*ptr & 0x1FF);

		++ptr; --size;
	}
}

void pcmaster_recordtask_create(char priority)
{
	rt_thread_t tid;

	tid = rt_thread_create("pcmst",
		rt_thread_entry_freemaster, RT_NULL,
		1024, priority, 20);//

	if (tid != RT_NULL)
		rt_thread_startup(tid);
	return ;

}


/* END PC_M1. */

/*
** ###################################################################
**
**     This file was created by UNIS Processor Expert 2.98 [03.79]
**     for the Freescale 56800 series of microcontrollers.
**
** ###################################################################
*/
