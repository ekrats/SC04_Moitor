/*****************************************************************************
*
* Copyright (c) 2007,深圳通业科技有限公司 .All rights reserved.
*
* -----------------------------------------------------------------------------
*
* 文件摘要:鸣笛监控装置的flash 或IC 卡驱动文件，ATMEL公司的
* AT45DXX等大容量FLASH /IC卡 的读写程序
*
* -----------------------------------------------------------------------------
*
* 文件名称:	At45drv.c
* 编译环境:	ads1.2
* 最新版本:  v1.0
* 硬件平台:  鸣笛监控V1.0 LPC213X
*****************************************************************************/

/***修改及版本记录*****************************************************************
* 修改时间:  2007/7/28
* 修改人员: 黄楚雄
* 升级版本:	V1.0
* 内容描述: 初次编写
*
**********************************************************************************/
/***修改及版本记录*****************************************************************
* 修改时间:  
* 修改人员:
* 升级版本:
* 内容描述:
*
**********************************************************************************/
//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
//
//                       【 AT45DBxxxx   芯片说明 】
//
//AT45xxx Series 
//Devices Description 
//AT45DB011D    1M bit , 2.7-Volt Minimum Serial-Interface Flash with One 264-Byte SRAM Buffer 
//AT45DB021D    2M bit , 2.7-Volt Minimum Serial-Interface Flash with One 264-Byte SRAM Buffer 
//AT45DB041D    4M bit , 2.5-Volt or 2.7-Volt DataFlash 
//AT45DB081D    8M bit , 2.5 or 2.7-Volt Only Serial-Interface Flash 
//AT45DB161D    16M bit, 2.7-Volt Only Serial-Interface Flash with two SRAM Data Buffers 
//AT45DB321D    32M bit, 2.7-Volt Only Serial Interface Flash with two SRAM Data Buffers
//AT45DB642D    64M bit, 2.7-Volt Dual-Interface Flash with two 1056-Byte SRAM 

//从AT45DB011D（1Mbit）、AT45DB021D（2Mbit）、AT45DB041D（4Mbit）、AT45DB081D（8Mbit）、
//AT45DB161D（16Mbit）、AT45DB321D（32Mbit）、AT45DB642D（64Mbit）全系列都有，其中
//011D~041D都是264字节Page的，161D和321D是528字节Page，642D是1056字节Page的。
//该系统都具有两个缓冲区，分别命令为BUF1和BUF2，在其它的Flash中很少见的。而且该系列
//的命令、封装都是通用的


//AT45DB161D是串行接口的闪存芯片，可工作在2.5V~2.7V，可广泛应用于数据语音、图像、程序
//代码数据存储中。AT45DB161D支持RapidS串行接口，适用于高速场合。RapidS串行接口是与SPI
//相兼容的，速度可达到66MHz。它包含有17,301,504个位，被组织为4096个页，每个页512或528
//个字节。除了主存储器，AT45DB161D还包括两个SRAM数据缓冲区，每个缓冲区512/528个字节。
//在主存储器正在编程时，缓冲区是允许接收数据的，并且支持数据流式写入。与并行FLASH储存
//器不同，它采用RapidS串行接口，从而大大减少了可用引脚数量，同时也提高了系统可靠性，降
//低了开关噪声，缩小了封装体积。可以应用于商业、工业等需要高密度、低引脚数、低电压与低
//功耗的应用场合。
//
//AT45DB161D允许简单的在系统重新编程，而无需输入高编程电压。芯片可以采用2.5V~3.6V或
//2.7V~3.6V单电源供电，进行编程与读取操作。它可以通过#CS来进行使能，并通过三线接口
//（SI、SO、SCK）进行数据通信。
//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------

//┌────┬────────────────────┬───────┬──────┐
//│  符号  │           名称与功能                   │   有效电平   │    类型    │
//├────┼────────────────────┼───────┼──────┤
//│  CS    │#CS引脚上的下降沿将会启动一个操作，而上 │   LOW        │   Input    │
//│        │升沿则会结束一个操作。在一个内部操作如芯│              │            │
//│        │片内部的编程或擦除周期内，芯片不会进入闲│              │            │
//│        │置状态，直到操作完毕.                   │              │            │
//├────┼────────────────────┼───────┼──────┤
//│  SCK   │串行时钟：此引脚用来向芯片提供时钟信号，│              │   Input    │
//│        │有来控制数据流的出入。SI引脚上的命令、地│              │            │
//│        │址与输入数据在时钟SCK的上升沿被写入，而 │              │            │
//│        │SO引脚上的输出数据则在时钟的下降沿变化. │              │            │
//├────┼────────────────────┼───────┼──────┤
//│  SI    │串行输入：SI引脚用来向芯片以移位方式写入│              │   Input    │
//│        │数据。SI引脚上的所有数据输入包括命令与地│              │            │
//│        │址。SI上的数据在时钟的上升沿写入芯片。  │              │            │
//├────┼────────────────────┼───────┼──────┤
//│  SO    │串行输出：SO引脚用来从芯片以移位方式输出│              │   Output   │
//│        │数据。SI上的数据在时钟的下降沿变化。    │              │            │
//├────┼────────────────────┼───────┼──────┤
//│  WP    │写保护：当#WP被设置为有效时芯片的扇区将 │   LOW        │   Input    │
//│        │被保护起来，以防止编程与擦除对数据的破坏│              │            │
//│        │。但是扇区保护使能与扇区死锁命令仍然可以│              │            │
//│        │被芯片识别。#WP引脚在内部被拉高，可以悬 │              │            │
//│        │空。但是仍然建议在外部接到VCC。         │              │            │
//├────┼────────────────────┼───────┼──────┤
//│  Reset │复位：#RESET引脚上的低电平会终止正在处理│   LOW        │   Input    │
//│        │的操作并复位内部状态机到闲置状态。#RESET│              │            │
//│        │引脚上的低电平会使芯片一直处于复位状态。│              │            │
//│        │当#RESET上转为高电平后，才能进行正常的操│              │            │
//│        │作。芯片内部设置上电复位电路。当此引脚不│              │            │
//│        │用时，外部接到高电平.                   │              │            │
//└────┴────────────────────┴───────┴──────┘
// 
// AT45DB161D的储存器阵列被分为3个级别的粒度，分别为扇区、块与页。下面的“存储器结构图”
// 对各个级别进行了分析，详细说明了每个扇区与块的页数。所有的编程操作都是针对于页的。
// 擦除操作可以作用于芯片、扇区、块或页。
//
//┌────────────────────┐
//│               扇区结构                 │
//├────────────────────┤
//│（扇区 0A）＝8页   4096  /4224   字节   │
//├────────────────────┤
//│（扇区 0B）＝248页 126,976/130,944字节  │
//├────────────────────┤
//│（扇区 1 ）＝256页 131,072/135,168字节  │
//├────────────────────┤
//│（扇区 2 ）＝256页 131,072/135,168字节  │
//├────────────────────┤
//│               ......                   │
//├────────────────────┤
//│（扇区 14）＝256页 131,072/135,168字节  │
//├────────────────────┤
//│（扇区 15）＝256页 131,072/135,168字节  │
//└────────────────────┘
// 
//
//
//
//
//
//


#define _AT45DRV_
#include <rtthread.h>
#include <stm32f4xx.h>
//#include "ds.h"	 
#include "at45Drv.h"
#include "spiDrv.h"

#define SetFCS (FLASH_CS_HIGH())
#define ClrFCS (FLASH_CS_LOW())

//超时判定用定时器变量
// #define TIME_TICKS_VAL    (OSTick)
// extern vu32 OSTick; //该变量要由Timer中断进行累加,累加频率1KHz         

//-----------------------------------------------------------------------------------
// SPI PORT
//-----------------------------------------------------------------------------------
#define SPI_DEVICE_PORT             (SPI2)



/*************************************以下内部函数，FLASH的底层操作函数*************************/



/****************************************************************************
** 函数名称：static u8 SPI_FLASH_SendByte(u8 byte) 
** 功    能：通过SPI发送一个字节数据
** 说    明： 
** 入口参数：无
** 出口参数：读取的数据
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
/*******************************************************************************
* Function Name  : SPI_SendByte
* Description    : Sends a byte through the SPI interface and return the byte
*                  received from the SPI bus.
* Input          : byte : byte to send.
* Output         : None
* Return         : The value of the received byte.
*******************************************************************************/
// rt_uint8_t SPI_SendByte(SPI_TypeDef* SPIx, rt_uint8_t byte)
// {
// 	rt_uint32_t i = 0 ;
// 	rt_uint32_t j = 0 ;
// 	/* Loop while DR register in not emplty */
// 	while ((SPI_I2S_GetFlagStatus(SPIx, SPI_I2S_FLAG_TXE) == RESET)&&(++i<1000000));
// 	/* Send byte through the SPI1 peripheral */
// 	SPI_I2S_SendData(SPIx, byte);
// 	/* Wait to receive a byte */
// 	while ((SPI_I2S_GetFlagStatus(SPIx, SPI_I2S_FLAG_RXNE) == RESET)&&(++j<1000000));
// 	/* Return the byte read from the SPI bus */
// 	return SPI_I2S_ReceiveData(SPIx) ;
// }
/****************************************************************************
** 函数名称：static u8 ICReadByte(void) 
** 功    能：读一个字节数据
** 说    明： 
** 入口参数：无
** 出口参数：读取的数据
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
static u8 ICReadByte(void)
{
	return(SPI_SendByte(SPI_DEVICE_PORT,0x0));
}

/****************************************************************************
** 函数名称：static void ICWriteByte(u8 data) 
** 功    能：写一个字节数据
** 说    明： 
** 入口参数：data 欲写的数据
** 出口参数：无
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
static void ICWriteByte(u8 data)
{
	SPI_SendByte(SPI_DEVICE_PORT,data);
}

/****************************************************************************
** 函数名称：static void ICWaitReady(void) 
** 功    能：根据状态字BUSY位进行阻塞延时等待
** 说    明：根据状态字的第8位如果该位为0则等待
** 入口参数：无
** 出口参数：无
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年7月30日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void ICWaitReady(void)                 
{
	u8 c;
	while (1)
	{
		c = ICStatus();
		if (c&0x80) break;
	}
}


AT45FlashStatus ICWaitReady_timeout(u16 timeout)                 
{
	u8 c;
    //u32 t;

    //t = 0;//
	while (1)
	{
		c = ICStatus();
		if(c & 0x80)
        {
            return AT45_FLASH_COMPLETE;
        }

//         if((TIME_TICKS_VAL - t) > timeout)
//         {
//             return AT45_FLASH_OP_TIMEOUT;
//         }
	}
}

/****************************************************************************
** 函数名称：static void ICCommand(OpCode cmd, u16 Page, u16 ByteAddr)
** 功    能：执行IC卡的操作指令
** 说    明：根据OPCODE的命令，对IC卡进行操作，
**           OPCODE的具体含义参加头文件
** 入口参数：cmd操作码; Page页代码; ByteAddr字节地址
** 出口参数：无
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年7月30日
**---------------------------------------------------------------------------
** 修改人：罗显能
** 日　期：2010-05-19
** 内　容：if判断中增加现在条件(cmd != DeepPowerDown)&&(cmd != ResumeDeepPowerDown))，以支持省电模式，退出省电模式命令
****************************************************************************/
/*IC卡命令选择执行*/
static void ICCommand(OpCode cmd, u16 Page, u16 ByteAddr)
{
	u8  temp     = 0 ;
	u32 cmd_temp = 0;
	u8  data;

	/*发送命令字*/
	ICWriteByte((u8)cmd);		

	if (   (cmd != StatusRead) 
		&& (cmd != IDRead)
		&& (cmd != DeepPowerDown)
		&& (cmd != ResumeDeepPowerDown)
		)//处理3个字节地址
	{
		cmd_temp =  (Page&0xfff) << 10;  //12位页地址PA0-PA11
		cmd_temp += (ByteAddr & 0x3FF);  //528模式下对应页下的字节地址PB0-PB9
		//发送是高位在前格式:PB0-PB9,PA0-PA11,XX
		data = (u8)(cmd_temp >> 16);
		ICWriteByte(data);
		data = (u8)(cmd_temp >> 8);
		ICWriteByte(data);
		data = (u8)cmd_temp ;
		ICWriteByte(data);

	}

	switch (cmd)
	{
	case PageRead:              //直接读页，缓存不变
		{
			temp = ICReadByte();	//发送32位无关位
			temp = ICReadByte();
			temp = ICReadByte();
			temp = ICReadByte();
			temp = temp ;
			//			ucResult = ICReadNextByte();
			break;
		}

	case Buf1Read:              //缓存1读
	case Buf2Read:             //缓存2读
		/*		{
		temp = ICReadByte();
		//			ucResult = ICReadNextByte();
		break;
		}
		*/
	case PageToBuf1:            //页读至缓存1
	case PageToBuf2:            //页读至缓存2
		{
			temp = ICReadByte();	//发送8位无关位
			break;
		}
		/*		case PageCmpBuf1:           //页与缓存1比较，比较结果在状态寄存器第6位
		case PageCmpBuf2:                   //页与缓存2比较，比较结果在状态寄存器第6位
		case Buf1Write:                     //缓存1写
		case Buf2Write:                     //缓存2写
		case Buf1ToPageWithErase:             //页擦除后，将缓存1写入页
		case Buf2ToPageWithErase:             //页擦除后，将缓存2写入页
		case Buf1ToPageWithoutErase:          //直接将缓存1写入页
		case Buf2ToPageWithoutErase:          //直接将缓存2写入页
		case PageWriteThroughBuf1:            //数据先写入缓存1，再写入页
		case PageWriteThroughBuf2:            //数据先写入缓存2，再写入页
		case PageRewriteThroughBuf1:          //页读入缓存1，然后缓存1写入页
		case PageRewriteThroughBuf2:          //页读入缓存2，然后缓存2写入页
		break;

		case StatusRead:                      //读状态寄存器
		//		ucResult = ICReadNextByte();
		break;
		*/
	default : break;
	}

}

/****************************************************************************
** 函数名称：static u8 ICReadBuf1Byte(u16 ByteAddr)
** 功    能：从缓存区1指定地址读一个字节数据
** 说    明： 
** 入口参数：ByteAddr起始地址
** 出口参数：读出数据
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
static u8 ICReadBuf1Byte(u16 ByteAddr)
{
	u8 Rt_Temp;

	ClrFCS;
	ICCommand(Buf1Read, 0, ByteAddr);
	Rt_Temp = ICReadByte();
	SetFCS;

	return (Rt_Temp);
}

/****************************************************************************
** 函数名称：static u8 ICReadBuf2Byte(u16 ByteAddr)
** 功    能：从缓存区2指定地址读一个字节数据
** 说    明： 
** 入口参数：ByteAddr起始地址
** 出口参数：读出数据
** 全局变量：
** 作　者： 黄楚雄
** 日　期： 2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
static u8 ICReadBuf2Byte(u16 ByteAddr)
{

	u8 Rt_Temp;

	ClrFCS;
	ICCommand(Buf2Read, 0, ByteAddr);
	Rt_Temp = ICReadByte();
	SetFCS;

	return (Rt_Temp);
}
/***************************************以下对外接口函数*************************************************************/

/****************************************************************************
** 函数名称：void  ICInit(void) 
** 功    能：初始化AT45DB161
** 说    明：无
** 入口参数：无
** 出口参数：无
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年7月30日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
u8 AT45ICInit(void)                  
{
	//SPI_FLASH_Init();

	ICIDR();  //读IC卡的ID
	ICID.sr = ICStatus(); 

	//判断FLASH储存器是否ATMEL公司的AT45DB161
	if(    ((ICID.sr & 0x3c) == 0x2c) 
		&& (ICID.mid == 0x1f) 
		&& (ICID.did1==0x26)
	  )
	{
		return (TRUE);
	}
	else
	{
		return(FALSE);
	}

}

/****************************************************************************
** 函数名称：u8 ICStatus(void)
** 功    能：读FLASH/IC卡状态
** 说    明：AT45DB161状态字为 
**           PAGE SIZE(BIT0):       1->512byte 0->528byte
**           PROTECT  (BIT1)：      1->保护  0->未保护 
**			 芯片序列码(BIT2-BIT5)：AT45DB161固定为 BIT2-BIT5->1101
**			 COMP(BIT6):            1->所比较页至少有一项数据与缓存区不等 0->所比较页与缓存区数据相等
**           RDY/-BUSY(BIT7):       1->空闲 0->忙
**
**           Bit 7    Bit 6    Bit 5    Bit 4    Bit 3    Bit 2    Bit 1      Bit 0
**           RDY/BUSY COMP       1        0        1        1     PROTECT   PAGE SIZE
** 入口参数：无
** 出口参数：IC卡状态字
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年7月30日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
u8 ICStatus(void)                     
{
	u8 ucResult;

	ClrFCS;
	ICCommand(StatusRead, 0, 0);
	ucResult = ICReadByte();
	SetFCS;

	return (ucResult);
}




/****************************************************************************
** 函数名称：void  ICIDR(void) 
** 功    能：读取IC卡存储器的出厂ID
** 说    明：出厂ID，1字节1F表示ATMEL公司2字节26表示16M DATAFLASH
** 入口参数：无
** 出口参数：无
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年7月30日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void  ICIDR(void)                  
{
	ClrFCS;
	ICCommand(IDRead, 0, 0);
	ICID.mid  = ICReadByte();
	ICID.did1 = ICReadByte();
	ICID.did2 = ICReadByte();
	ICID.einf = ICReadByte();
	SetFCS;
}
/****************************************************************************
** 函数名称：u8 ICWriteToPage(u8 *pData,u16 Page, u16 ByteAddr, u16 Size, u8 Operation)
** 功    能：页写操作函数,包含擦除操作
** 说    明： 
** 入口参数：p内容 count数量 page 写的页面byteaddr 写的字节地址
operation 操作方式，有ADD和NEW，追加数据或者全新数据
** 出口参数：写成功与否
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
u8 ICWriteToPage(u8 *pData,u16 Page, u16 ByteAddr, u16 Size, u8 Operation)
{

	/*读取页内容至缓存2*/
	if((Operation == OpCmdADD)||(Operation == OpCmdADDCLR))
	{
		ICPageToBuf2(Page);    
		ICWaitReady();
	}
	/*写入字符串至缓存2*/
	ICWriteBuf2(ByteAddr, pData,Size);
	if((Operation == OpCmdNEWCLR)||(Operation == OpCmdADDCLR))
	{
		ICWriteBuf2((ByteAddr+Size), NULL, (528 - Size - ByteAddr));
	}
	/*缓存2写入页*/
	ICBuf2ToPage(Page);
	ICWaitReady();

	/*比较写入是否成功*/
	return (ICBuf2CmpPage(Page));
}
/****************************************************************************
** 函数名称：void ICWriteFullPage(u8 *pData, u16 page, u8 bufferIndex)
** 功    能：FLASH整页写,不需要预擦除.
** 说    明：  
** 入口参数：*pData       欲写入的数据,  
             page         页面
             bufferIndex  使用的Ram缓冲区
** 出口参数：无
** 全局变量：
** 作　  者： 
** 日　  期： 
**---------------------------------------------------------------------------
** 修 改 人：
** 日　  期：
** 内　  容：
****************************************************************************/
void ICWriteFullPage(u8 *pData, u16 page, u8 bufferIndex)
{
	switch(bufferIndex)
	{
	case 0:
		ICWriteBuf1(0, pData, 528);

		ClrFCS;
		ICCommand(Buf1ToPageWithoutErase, page, 0);
		SetFCS;

		break;
	case 1:
		ICWriteBuf2(0, pData, 528);

		ClrFCS;
		ICCommand(Buf2ToPageWithoutErase, page, 0);
		SetFCS;
		break;

	}

}
/****************************************************************************
** 函数名称：void ICReadPage(u8 *pData, u16 Page, u16 ByteAddr, u16 size)
** 功    能：FLASH直接页读取
** 说    明：根据页面和地址，读取一定数量的数据返回 
** 入口参数：*pData读取返回的数据,  page 读的页面byteaddr 读的字节起始地址
size读取的字节数量
** 出口参数：无
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void ICReadPage(u8 *pData, u16 Page, u16 ByteAddr, u16 Size)
{
	u16 i;

	//	Size = Size&0x1ff;

	ClrFCS;
	ICCommand(PageRead, Page, ByteAddr);

	for(i=0;i<Size;i++)
	{
		*pData++ = ICReadByte();
	}

	SetFCS;
}

/****************************************************************************
** 函数名称：void ICWriteBuf1(u16 ByteAddr,u8 *pData,u16 Size)
** 功    能：缓存1写操作函数
** 说    明： 
** 入口参数：ByteAddr起始地址pdata写入的数据 size数据长度
** 出口参数：写成功与否
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void ICWriteBuf1(u16 ByteAddr,u8 *pData,u16 Size)
{
	u16 i;

	//	Size = Size&0x1ff;

	ClrFCS;
	ICCommand(Buf1Write, 0, ByteAddr);

	for(i = 0; i < Size; i++)
	{
		ICWriteByte(*pData++);
	}

	SetFCS;
}

/****************************************************************************
** 函数名称：void ICWriteBuf2(u16 ByteAddr,u8 *pData,u16 Size)
** 功    能：缓存2写操作函数
** 说    明： 
** 入口参数：ByteAddr起始地址pdata写入的数据 size数据长度
** 出口参数：写成功与否
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void ICWriteBuf2(u16 ByteAddr,u8 *pData,u16 Size)
{
	u16 i;

	//	Size &= 0x3ff;

	ClrFCS;
	ICCommand(Buf2Write, 0, ByteAddr);

	if(pData == (u8 *)NULL)
	{
		for(i = 0; i < Size; i++)
		{
			ICWriteByte(0);
		}
	}
	else
	{
		for(i = 0; i < Size; i++)
		{
			ICWriteByte(*pData++);
		}
	}

	SetFCS;
}



/****************************************************************************
** 函数名称：u8  ICBuf1CmpPage(u16 Page)
** 功    能：比较缓存1与flash页的内容
** 说    明： 
** 入口参数：page 比较页面
** 出口参数：比较缓存区1与该页数据是否相等 TRUE:相等；FALSE：不等
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
u8  ICBuf1CmpPage(u16 Page)
{

	ClrFCS;
	ICCommand(PageCmpBuf1, Page, 0);
	SetFCS;

	ICWaitReady();

	//判断写入结果，如果SR寄存器6位为1则写入有错误
	if(ICStatus() & 0x40) return (FALSE);
	else return (TRUE);
}

/****************************************************************************
** 函数名称：u8   ICBuf2CmpPage(u16 Page)
** 功    能：比较缓存2与flash页的内容
** 说    明： 
** 入口参数：page 比较页面
** 出口参数：比较缓存区2与该页数据是否相等 TRUE:相等；FALSE：不等
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
u8  ICBuf2CmpPage(u16 Page)
{

	ClrFCS;
	ICCommand(PageCmpBuf2, Page, 0);
	SetFCS;

	ICWaitReady();

	//判断写入结果，如果SR寄存器6位为1则写入有错误
	if(ICStatus() & 0x40) return (FALSE);
	else return (TRUE);
}

/****************************************************************************
** 函数名称：void  ICBuf1ToPage(u16 Page)
** 功    能：缓存1写入到flash页写操作函数
** 说    明： 
** 入口参数：page 写的页面
** 出口参数：
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void  ICBuf1ToPage(u16 Page)
{
	ClrFCS;
	ICCommand(Buf1ToPageWithErase, Page, 0);
	SetFCS;
}

void  ICBuf1ToPageN(u16 Page)
{
	ClrFCS;
	ICCommand(Buf1ToPageWithoutErase, Page, 0);
	SetFCS;
}

/****************************************************************************
** 函数名称：void  ICBuf2ToPage(u16 Page)
** 功    能：缓存2写入到flash页写操作函数
** 说    明： 
** 入口参数：page 写的页面
** 出口参数：
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void  ICBuf2ToPage(u16 Page)
{
	ClrFCS;
	ICCommand(Buf2ToPageWithErase, Page, 0);
	SetFCS;
}

void  ICBuf2ToPageN(u16 Page)
{
	ClrFCS;
	ICCommand(Buf2ToPageWithoutErase, Page, 0);
	SetFCS;
}

/****************************************************************************
** 函数名称：void  ICPageToBuf1(u16 Page) 
** 功    能：将FLASH页数据读入到缓存1中
** 说    明： 
** 入口参数：page 读的页面
** 出口参数：无
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void  ICPageToBuf1(u16 Page)       
{
	ClrFCS;
	ICCommand(PageToBuf1, Page, 0);
	SetFCS;
}

/****************************************************************************
** 函数名称：void  ICPageToBuf2(u16 Page) 
** 功    能：将FLASH页数据读入到缓存2中
** 说    明： 
** 入口参数：page 读的页面
** 出口参数：无
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void  ICPageToBuf2(u16 Page)       
{
	ClrFCS;
	ICCommand(PageToBuf2, Page, 0);
	SetFCS;
}

/****************************************************************************
** 函数名称：void  ICPageErase(u16 Page) 
** 功    能：页擦除
** 说    明： 
** 入口参数：Page 欲擦除的页(0-4095)
** 出口参数：无
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void  ICPageErase(u16 Page)       
{
	ClrFCS;
	ICCommand(PageErase, Page, 0);
	SetFCS;
}


/****************************************************************************
** 函数名称：u8 ICSectorErase(u8 Sector,EraseSectorProperty EraseSector_Property) 
** 功    能：擦除扇区
** 说    明： 
** 入口参数：Sector 欲擦除扇区;	EraseSector_Property:擦除扇区属性 Erase_0_Sector->擦除扇区0；Erase_other_Sector->擦除扇区1-15
** 出口参数：无
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：罗显能
** 日　期：2010-05-19
** 内　容：原来只支持1-15扇区擦除，修改后支持所有扇区擦除
****************************************************************************/
u8  ICSectorErase(u8 Sector,EraseSectorProperty EraseSector_Property)      
{
	u8 data;

	if(Erase_0_Sector == EraseSector_Property) //扇区0擦除
	{
		if((SECTOR_0A == Sector)||(SECTOR_0B == Sector))
		{
			ClrFCS;
			ICCommand(SectorErase, (u16)Sector, 0);
			SetFCS;

			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	else if(Erase_other_Sector == EraseSector_Property)	//扇区1-15擦除
	{
		if((Sector == 0) || (Sector > 15))
		{
			return FALSE;
		}

		ClrFCS;
		/*发送命令字*/
		ICWriteByte((u8)SectorErase);
		data = Sector << 2;
		ICWriteByte(data);
		ICWriteByte(0);
		ICWriteByte(0);
		SetFCS;
		return TRUE;
	}

	return FALSE;
}

/****************************************************************************
** 函数名称：void ICReadBuf1(u16 ByteAddr,u8 *pData,u16 Size)
** 功    能：读缓存区1数据
** 说    明： 
** 入口参数：ByteAddr 缓存区1地址;	*pData:读取数据缓存区首地址； Size：读取数据长度
** 出口参数：无
** 全局变量：
** 作　者：罗显能
** 日　期：2010年5月19日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void ICReadBuf1(u16 ByteAddr,u8 *pData,u16 Size)
{
	u16 read_loop;
	for(read_loop = 0; read_loop < Size; read_loop++)
	{
		pData[read_loop] = ICReadBuf1Byte(ByteAddr);
		ByteAddr++;
	}
}

/****************************************************************************
** 函数名称：void ICReadBuf2(u16 ByteAddr,u8 *pData,u16 Size)
** 功    能：读缓存区2数据
** 说    明： 
** 入口参数：ByteAddr 缓存区2地址;	*pData:读取数据缓存区首地址； Size：读取数据长度
** 出口参数：无
** 全局变量：
** 作　者：罗显能
** 日　期：2010年5月19日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void ICReadBuf2(u16 ByteAddr,u8 *pData,u16 Size)
{
	u16 read_loop;
	for(read_loop = 0; read_loop < Size; read_loop++)
	{
		pData[read_loop] = ICReadBuf2Byte(ByteAddr);
		ByteAddr++;
	}
}
/****************************************************************************
** 函数名称：void ICDeepPowerDown(void)
** 功    能：使AT45DB161进入省电模式
** 说    明：省电模式期间，AT45DB161只接收识别退出省电模式命令，其它命令忽略
** 入口参数：无
** 出口参数：无
** 全局变量：
** 作　者：罗显能
** 日　期：2010年5月19日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void ICDeepPowerDown(void)                     
{
	ClrFCS;
	ICCommand(DeepPowerDown, 0, 0);
	SetFCS;
}

/****************************************************************************
** 函数名称：void ICResumeDeepPowerDown(void)
** 功    能：使AT45DB161退出省电模式
** 说    明：
** 入口参数：无
** 出口参数：无
** 全局变量：
** 作　者：罗显能
** 日　期：2010年5月19日
**---------------------------------------------------------------------------
** 修改人：
** 日　期：
** 内　容：
****************************************************************************/
void ICResumeDeepPowerDown(void)                  
{
	ClrFCS;
	ICCommand(ResumeDeepPowerDown, 0, 0);
	SetFCS;
}

/****************************************************************************
** 函数名称：u8 ICSectorErase(u8 Sector,EraseSectorProperty EraseSector_Property) 
** 功    能：擦除扇区
** 说    明： 
** 入口参数：Sector 欲擦除扇区;	EraseSector_Property:擦除扇区属性 Erase_0_Sector->擦除扇区0；Erase_other_Sector->擦除扇区1-15
** 出口参数：无
** 全局变量：
** 作　者：黄楚雄
** 日　期：2007年8月16日
**---------------------------------------------------------------------------
** 修改人：罗显能
** 日　期：2010-05-19
** 内　容：原来只支持1-15扇区擦除，修改后支持所有扇区擦除
****************************************************************************/
u8 ICBlockErase(u16 Block)
{   
	u16 buf_block = 0;


	if(512 < buf_block)
	{
		return FALSE;
	}

	buf_block =(Block & 0x1FF) << 3; 
	ClrFCS;
	ICCommand(BlockErase, buf_block, 0);
	SetFCS;

	return TRUE;

} 





/*********************** End Of File ****************************************************/










